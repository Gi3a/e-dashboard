import { inject as pn, provide as fn, shallowRef as vn, watchEffect as Q, readonly as it, ref as $, watch as X, customRef as ro, computed as S, nextTick as Y, getCurrentScope as Sa, onScopeDispose as Ta, effectScope as Da, unref as a, toRef as Oa, getCurrentInstance as Le, onMounted as q, Fragment as ie, defineComponent as g, toRefs as U, renderSlot as y, onBeforeUnmount as uo, onBeforeUpdate as Ia, onUpdated as Aa, toHandlerKey as Ma, camelize as mn, onUnmounted as fe, mergeProps as T, h as Ve, cloneVNode as ka, openBlock as h, createBlock as b, withCtx as v, createVNode as M, createCommentVNode as G, withKeys as le, Teleport as Ge, normalizeProps as R, guardReactiveProps as K, normalizeStyle as ae, reactive as hn, withModifiers as oe, createElementBlock as Z, mergeDefaults as yn, createElementVNode as rt, renderList as co, markRaw as Qo, withDirectives as po, vShow as gn, resolveDynamicComponent as _e, createTextVNode as ue, toDisplayString as Ke, isRef as ut, onBeforeMount as bn, vModelSelect as Ra, useSlots as Cn } from "vue";
import { useFloating as Va, autoUpdate as Fa, offset as La, shift as Ka, limitShift as Na, flip as Ha, size as Wa, arrow as ja, hide as za } from "@floating-ui/vue";
function W(o, t) {
  const e = typeof o == "string" && !t ? `${o}Context` : t, n = Symbol(e);
  return [(i) => {
    const r = pn(n, i);
    if (r || r === null)
      return r;
    throw new Error(
      `Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(o) ? `one of the following components: ${o.join(
        ", "
      )}` : `\`${o}\``}`
    );
  }, (i) => (fn(n, i), i)];
}
function fo(o, t, e) {
  const n = e.originalEvent.target, s = new CustomEvent(o, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && n.addEventListener(o, t, { once: !0 }), n.dispatchEvent(s);
}
function Ua(o, t) {
  var e;
  const n = vn();
  return Q(() => {
    n.value = o();
  }, {
    ...t,
    flush: (e = t == null ? void 0 : t.flush) != null ? e : "sync"
  }), it(n);
}
function vo(o, t) {
  let e, n, s;
  const l = $(!0), i = () => {
    l.value = !0, s();
  };
  X(o, i, { flush: "sync" });
  const r = typeof t == "function" ? t : t.get, u = typeof t == "function" ? void 0 : t.set, d = ro((p, c) => (n = p, s = c, {
    get() {
      return l.value && (e = r(), l.value = !1), n(), e;
    },
    set(f) {
      u == null || u(f);
    }
  }));
  return Object.isExtensible(d) && (d.trigger = i), d;
}
function dt(o) {
  return Sa() ? (Ta(o), !0) : !1;
}
function St(o) {
  let t = !1, e;
  const n = Da(!0);
  return (...s) => (t || (e = n.run(() => o(...s)), t = !0), e);
}
function ge(o) {
  return typeof o == "function" ? o() : a(o);
}
const Ee = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const qa = (o) => typeof o < "u", Ga = Object.prototype.toString, Ya = (o) => Ga.call(o) === "[object Object]", en = (o, t, e) => Math.min(e, Math.max(t, o)), at = () => {
}, tn = /* @__PURE__ */ Xa();
function Xa() {
  var o, t;
  return Ee && ((o = window == null ? void 0 : window.navigator) == null ? void 0 : o.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Ja(o, t) {
  function e(...n) {
    return new Promise((s, l) => {
      Promise.resolve(o(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(s).catch(l);
    });
  }
  return e;
}
function Za(o, t = {}) {
  let e, n, s = at;
  const l = (r) => {
    clearTimeout(r), s(), s = at;
  };
  return (r) => {
    const u = ge(o), d = ge(t.maxWait);
    return e && l(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (l(n), n = null), Promise.resolve(r())) : new Promise((p, c) => {
      s = t.rejectOnCancel ? c : p, d && !n && (n = setTimeout(() => {
        e && l(e), n = null, p(r());
      }, d)), e = setTimeout(() => {
        n && l(n), n = null, p(r());
      }, u);
    });
  };
}
function Qa(...o) {
  if (o.length !== 1)
    return Oa(...o);
  const t = o[0];
  return typeof t == "function" ? it(ro(() => ({ get: t, set: at }))) : $(t);
}
function mo(o, t = 1e4) {
  return ro((e, n) => {
    let s = ge(o), l;
    const i = () => setTimeout(() => {
      s = ge(o), n();
    }, ge(t));
    return dt(() => {
      clearTimeout(l);
    }), {
      get() {
        return e(), s;
      },
      set(r) {
        s = r, n(), clearTimeout(l), l = i();
      }
    };
  });
}
function ho(o, t = 200, e = {}) {
  return Ja(
    Za(t, e),
    o
  );
}
function yo(o, t, e = {}) {
  const {
    immediate: n = !0
  } = e, s = $(!1);
  let l = null;
  function i() {
    l && (clearTimeout(l), l = null);
  }
  function r() {
    s.value = !1, i();
  }
  function u(...d) {
    i(), s.value = !0, l = setTimeout(() => {
      s.value = !1, l = null, o(...d);
    }, ge(t));
  }
  return n && (s.value = !0, Ee && u()), dt(r), {
    isPending: it(s),
    start: u,
    stop: r
  };
}
function es(o = 1e3, t = {}) {
  const {
    controls: e = !1,
    callback: n
  } = t, s = yo(
    n ?? at,
    o,
    t
  ), l = S(() => !s.isPending.value);
  return e ? {
    ready: l,
    ...s
  } : l;
}
function ts(o, t, e) {
  const n = X(o, (...s) => (Y(() => n()), t(...s)), e);
  return n;
}
function ve(o) {
  var t;
  const e = ge(o);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const ct = Ee ? window : void 0;
function Se(...o) {
  let t, e, n, s;
  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([e, n, s] = o, t = ct) : [t, e, n, s] = o, !t)
    return at;
  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);
  const l = [], i = () => {
    l.forEach((p) => p()), l.length = 0;
  }, r = (p, c, f, m) => (p.addEventListener(c, f, m), () => p.removeEventListener(c, f, m)), u = X(
    () => [ve(t), ge(s)],
    ([p, c]) => {
      if (i(), !p)
        return;
      const f = Ya(c) ? { ...c } : c;
      l.push(
        ...e.flatMap((m) => n.map((C) => r(p, m, C, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    u(), i();
  };
  return dt(d), d;
}
function os(o) {
  return typeof o == "function" ? o : typeof o == "string" ? (t) => t.key === o : Array.isArray(o) ? (t) => o.includes(t.key) : () => !0;
}
function go(...o) {
  let t, e, n = {};
  o.length === 3 ? (t = o[0], e = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == "object" ? (t = !0, e = o[0], n = o[1]) : (t = o[0], e = o[1]) : (t = !0, e = o[0]);
  const {
    target: s = ct,
    eventName: l = "keydown",
    passive: i = !1,
    dedupe: r = !1
  } = n, u = os(t);
  return Se(s, l, (p) => {
    p.repeat && ge(r) || u(p) && e(p);
  }, i);
}
function ns(o = {}) {
  var t;
  const {
    window: e = ct,
    deep: n = !0
  } = o, s = (t = o.document) != null ? t : e == null ? void 0 : e.document, l = () => {
    var r;
    let u = s == null ? void 0 : s.activeElement;
    if (n)
      for (; u != null && u.shadowRoot; )
        u = (r = u == null ? void 0 : u.shadowRoot) == null ? void 0 : r.activeElement;
    return u;
  }, i = vo(
    () => null,
    () => l()
  );
  return e && (Se(e, "blur", (r) => {
    r.relatedTarget === null && i.trigger();
  }, !0), Se(e, "focus", i.trigger, !0)), i;
}
function Tt() {
  const o = $(!1);
  return Le() && q(() => {
    o.value = !0;
  }), o;
}
function as(o) {
  const t = Tt();
  return S(() => (t.value, !!o()));
}
function ss(o, t = {}) {
  const {
    immediate: e = !0,
    fpsLimit: n = void 0,
    window: s = ct
  } = t, l = $(!1), i = n ? 1e3 / n : null;
  let r = 0, u = null;
  function d(f) {
    if (!l.value || !s)
      return;
    const m = f - (r || f);
    if (i && m < i) {
      u = s.requestAnimationFrame(d);
      return;
    }
    o({ delta: m, timestamp: f }), r = f, u = s.requestAnimationFrame(d);
  }
  function p() {
    !l.value && s && (l.value = !0, u = s.requestAnimationFrame(d));
  }
  function c() {
    l.value = !1, u != null && s && (s.cancelAnimationFrame(u), u = null);
  }
  return e && p(), dt(c), {
    isActive: it(l),
    pause: c,
    resume: p
  };
}
function ls(o) {
  return JSON.parse(JSON.stringify(o));
}
function we(o, t, e = {}) {
  const { window: n = ct, ...s } = e;
  let l;
  const i = as(() => n && "ResizeObserver" in n), r = () => {
    l && (l.disconnect(), l = void 0);
  }, u = S(() => Array.isArray(o) ? o.map((c) => ve(c)) : [ve(o)]), d = X(
    u,
    (c) => {
      if (r(), i.value && n) {
        l = new ResizeObserver(t);
        for (const f of c)
          f && l.observe(f, s);
      }
    },
    { immediate: !0, flush: "post", deep: !0 }
  ), p = () => {
    r(), d();
  };
  return dt(p), {
    isSupported: i,
    stop: p
  };
}
function is(o, t = {}) {
  const e = ns(t), n = S(() => ve(o));
  return { focused: S(() => n.value && e.value ? n.value.contains(e.value) : !1) };
}
function rs(o, t) {
  const e = vn(t);
  return X(
    Qa(o),
    (n, s) => {
      e.value = s;
    },
    { flush: "sync" }
  ), it(e);
}
function J(o, t, e, n = {}) {
  var s, l, i;
  const {
    clone: r = !1,
    passive: u = !1,
    eventName: d,
    deep: p = !1,
    defaultValue: c,
    shouldEmit: f
  } = n, m = Le(), C = e || (m == null ? void 0 : m.emit) || ((s = m == null ? void 0 : m.$emit) == null ? void 0 : s.bind(m)) || ((i = (l = m == null ? void 0 : m.proxy) == null ? void 0 : l.$emit) == null ? void 0 : i.bind(m == null ? void 0 : m.proxy));
  let w = d;
  t || (t = "modelValue"), w = w || `update:${t.toString()}`;
  const P = (x) => r ? typeof r == "function" ? r(x) : ls(x) : x, _ = () => qa(o[t]) ? P(o[t]) : c, E = (x) => {
    f ? f(x) && C(w, x) : C(w, x);
  };
  if (u) {
    const x = _(), B = $(x);
    let I = !1;
    return X(
      () => o[t],
      (A) => {
        I || (I = !0, B.value = P(A), Y(() => I = !1));
      }
    ), X(
      B,
      (A) => {
        !I && (A !== o[t] || p) && E(A);
      },
      { deep: p }
    ), B;
  } else
    return S({
      get() {
        return _();
      },
      set(x) {
        E(x);
      }
    });
}
function Dt(o) {
  return o ? o.flatMap((t) => t.type === ie ? Dt(t.children) : [t]) : [];
}
function Ye(o, t, e, n = {}) {
  if (!t)
    return null;
  const {
    arrowKeyOptions: s = "both",
    attributeName: l = "data-radix-vue-collection-item",
    itemsArray: i = [],
    loop: r = !0,
    dir: u = "ltr",
    preventScroll: d = !0,
    focus: p = !1
  } = n, [c, f, m, C, w, P] = [
    o.key === "ArrowRight",
    o.key === "ArrowLeft",
    o.key === "ArrowUp",
    o.key === "ArrowDown",
    o.key === "Home",
    o.key === "End"
  ], _ = m || C, E = c || f;
  if (!w && !P && (!_ && !E || s === "vertical" && E || s === "horizontal" && _))
    return null;
  const x = e ? Array.from(e.querySelectorAll(`[${l}]`)) : i;
  if (!x.length)
    return null;
  d && o.preventDefault();
  let B = null;
  return E || _ ? B = _n(x, t, {
    goForward: _ ? C : u === "ltr" ? c : f,
    loop: r
  }) : w ? B = x.at(0) || null : P && (B = x.at(-1) || null), p && (B == null || B.focus()), B;
}
function _n(o, t, { goForward: e, loop: n }, s = o.length) {
  if (--s === 0)
    return null;
  const l = o.indexOf(t), i = e ? l + 1 : l - 1;
  if (!n && (i < 0 || i >= o.length))
    return null;
  const r = (i + o.length) % o.length, u = o[r];
  return u ? u.hasAttribute("disabled") && u.getAttribute("disabled") !== "false" ? _n(
    o,
    u,
    { goForward: e, loop: n },
    s
  ) : u : null;
}
function Xt(o) {
  if (o === null || typeof o != "object")
    return !1;
  const t = Object.getPrototypeOf(o);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in o ? !1 : Symbol.toStringTag in o ? Object.prototype.toString.call(o) === "[object Module]" : !0;
}
function to(o, t, e = ".", n) {
  if (!Xt(t))
    return to(o, {}, e, n);
  const s = Object.assign({}, t);
  for (const l in o) {
    if (l === "__proto__" || l === "constructor")
      continue;
    const i = o[l];
    i != null && (n && n(s, l, i, e) || (Array.isArray(i) && Array.isArray(s[l]) ? s[l] = [...i, ...s[l]] : Xt(i) && Xt(s[l]) ? s[l] = to(
      i,
      s[l],
      (e ? `${e}.` : "") + l.toString(),
      n
    ) : s[l] = i));
  }
  return s;
}
function us(o) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((e, n) => to(e, n, "", o), {})
  );
}
const ds = us(), [wn, cs] = W("ConfigProvider"), Yr = /* @__PURE__ */ g({
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    scrollBody: { type: [Boolean, Object], default: !0 }
  },
  setup(o) {
    const t = o, { dir: e, scrollBody: n } = U(t);
    return cs({
      dir: e,
      scrollBody: n
    }), (s, l) => y(s.$slots, "default");
  }
}), ps = St(() => $()), fs = St(() => $(0));
function pt(o) {
  const t = wn({
    scrollBody: $(!0)
  }), e = fs(), n = ps(), s = $(o);
  let l = null;
  const i = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = n.value ?? "", tn && (l == null || l()), n.value = void 0;
  };
  return o && e.value++, X(s, (r) => {
    var u;
    if (Ee && r) {
      n.value === void 0 && (n.value = document.body.style.overflow);
      const d = window.innerWidth - document.documentElement.clientWidth, p = { padding: d, margin: 0 }, c = (u = t.scrollBody) != null && u.value ? typeof t.scrollBody.value == "object" ? ds({
        padding: t.scrollBody.value.padding === !0 ? d : t.scrollBody.value.padding,
        margin: t.scrollBody.value.margin === !0 ? d : t.scrollBody.value.margin
      }, p) : p : { padding: 0, margin: 0 };
      d > 0 && (document.body.style.paddingRight = `${c.padding}px`, document.body.style.marginRight = `${c.margin}px`, document.body.style.setProperty("--scrollbar-width", `${d}px`), document.body.style.overflow = "hidden"), tn && (l = Se(
        window,
        "touchmove",
        (f) => {
          var m;
          f.touches.length > 1 || (m = f.preventDefault) == null || m.call(f);
        },
        { passive: !1 }
      )), Y(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }
  }, { immediate: !0 }), uo(() => {
    o && e.value--, e.value === 0 && i();
  }), s;
}
const vs = "data-radix-vue-collection-item";
function re(o, t = vs) {
  const e = o ?? Symbol();
  return { createCollection: (l) => {
    const i = $([]);
    function r() {
      const u = ve(l);
      return u ? i.value = Array.from(
        u.querySelectorAll(`[${t}]:not([data-disabled=true])`)
      ) : i.value = [];
    }
    return Ia(() => {
      i.value = [];
    }), q(r), Aa(r), X(() => l == null ? void 0 : l.value, r, { immediate: !0 }), fn(e, i), i;
  }, injectCollection: () => pn(e, $([])) };
}
function de(o) {
  const t = wn({
    dir: $("ltr")
  });
  return S(() => {
    var e;
    return (o == null ? void 0 : o.value) || ((e = t.dir) == null ? void 0 : e.value) || "ltr";
  });
}
function ce(o) {
  const t = Le(), e = t == null ? void 0 : t.type.emits, n = {};
  return e != null && e.length || console.warn(
    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`
  ), e == null || e.forEach((s) => {
    n[Ma(mn(s))] = (...l) => o(s, ...l);
  }), n;
}
let Jt = 0;
function bo() {
  Q((o) => {
    if (!Ee)
      return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? on()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? on()
    ), Jt++, o(() => {
      Jt === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), Jt--;
    });
  });
}
function on() {
  const o = document.createElement("span");
  return o.setAttribute("data-radix-focus-guard", ""), o.tabIndex = 0, o.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", o;
}
function Ne(o) {
  return S(() => {
    var t;
    return ge(o) ? !!((t = ve(o)) != null && t.closest("form")) : !0;
  });
}
function Ot(o) {
  const t = Le(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((n, s) => {
    const l = (t == null ? void 0 : t.type.props[s]).default;
    return l !== void 0 && (n[s] = l), n;
  }, {});
  return vo(() => ({ ...o }), () => {
    const n = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(s).forEach((l) => {
      n[mn(l)] = s[l];
    }), Object.keys({ ...e, ...n }).reduce((l, i) => (o[i] !== void 0 && (l[i] = o[i]), l), {});
  });
}
function pe(o, t) {
  const e = Ot(o), n = t ? ce(t) : {};
  return S(() => ({
    ...e.value,
    ...n
  }));
}
function be() {
  const o = Le();
  function t(e) {
    typeof e == "object" && (o.exposed = e, o.exposeProxy = e);
  }
  return t;
}
var ms = function(o) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(o) ? o[0] : o;
  return t.ownerDocument.body;
}, qe = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), bt = {}, Zt = 0, En = function(o) {
  return o && (o.host || En(o.parentNode));
}, hs = function(o, t) {
  return t.map(function(e) {
    if (o.contains(e))
      return e;
    var n = En(e);
    return n && o.contains(n) ? n : (console.error("aria-hidden", e, "in not contained inside", o, ". Doing nothing"), null);
  }).filter(function(e) {
    return !!e;
  });
}, ys = function(o, t, e, n) {
  var s = hs(t, Array.isArray(o) ? o : [o]);
  bt[e] || (bt[e] = /* @__PURE__ */ new WeakMap());
  var l = bt[e], i = [], r = /* @__PURE__ */ new Set(), u = new Set(s), d = function(c) {
    !c || r.has(c) || (r.add(c), d(c.parentNode));
  };
  s.forEach(d);
  var p = function(c) {
    !c || u.has(c) || Array.prototype.forEach.call(c.children, function(f) {
      if (r.has(f))
        p(f);
      else {
        var m = f.getAttribute(n), C = m !== null && m !== "false", w = (qe.get(f) || 0) + 1, P = (l.get(f) || 0) + 1;
        qe.set(f, w), l.set(f, P), i.push(f), w === 1 && C && gt.set(f, !0), P === 1 && f.setAttribute(e, "true"), C || f.setAttribute(n, "true");
      }
    });
  };
  return p(t), r.clear(), Zt++, function() {
    i.forEach(function(c) {
      var f = qe.get(c) - 1, m = l.get(c) - 1;
      qe.set(c, f), l.set(c, m), f || (gt.has(c) || c.removeAttribute(n), gt.delete(c)), m || c.removeAttribute(e);
    }), Zt--, Zt || (qe = /* @__PURE__ */ new WeakMap(), qe = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), bt = {});
  };
}, gs = function(o, t, e) {
  e === void 0 && (e = "data-aria-hidden");
  var n = Array.from(Array.isArray(o) ? o : [o]), s = t || ms(o);
  return s ? (n.push.apply(n, Array.from(s.querySelectorAll("[aria-live]"))), ys(n, s, e, "aria-hidden")) : function() {
    return null;
  };
};
function ft(o) {
  let t;
  X(() => ve(o), (e) => {
    e ? t = gs(e) : t && t();
  }), fe(() => {
    t && t();
  });
}
const bs = St(() => ({ count: $(0) }));
function te(o) {
  const { count: t } = bs();
  return o || t.value++, o || `radix-${t.value}`;
}
function xn(o) {
  const t = $(), e = S(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.width) ?? 0;
  }), n = S(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.height) ?? 0;
  });
  return q(() => {
    const s = ve(o);
    if (s) {
      t.value = { width: s.offsetWidth, height: s.offsetHeight };
      const l = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const r = i[0];
        let u, d;
        if ("borderBoxSize" in r) {
          const p = r.borderBoxSize, c = Array.isArray(p) ? p[0] : p;
          u = c.inlineSize, d = c.blockSize;
        } else
          u = s.offsetWidth, d = s.offsetHeight;
        t.value = { width: u, height: d };
      });
      return l.observe(s, { box: "border-box" }), () => l.unobserve(s);
    } else
      t.value = void 0;
  }), {
    width: e,
    height: n
  };
}
function $n(o, t) {
  const e = $(o);
  function n(l) {
    return t[e.value][l] ?? e.value;
  }
  return {
    state: e,
    dispatch: (l) => {
      e.value = n(l);
    }
  };
}
function Co(o) {
  const t = mo("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (s) => {
      var c, f;
      t.value = t.value + s;
      const l = o.value, i = document.activeElement, r = ((f = (c = l.find((m) => m === i)) == null ? void 0 : c.textContent) == null ? void 0 : f.trim()) ?? "", u = l.map((m) => {
        var C;
        return ((C = m.textContent) == null ? void 0 : C.trim()) ?? "";
      }), d = Cs(u, t.value, r), p = l.find(
        (m) => {
          var C;
          return ((C = m.textContent) == null ? void 0 : C.trim()) === d;
        }
      );
      p && p.focus();
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function _o(o, t) {
  return o.map((e, n) => o[(t + n) % o.length]);
}
function Cs(o, t, e) {
  const s = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, l = e ? o.indexOf(e) : -1;
  let i = _o(o, Math.max(l, 0));
  s.length === 1 && (i = i.filter((d) => d !== e));
  const u = i.find(
    (d) => d.toLowerCase().startsWith(s.toLowerCase())
  );
  return u !== e ? u : void 0;
}
function Xr(o, t) {
  return {
    inheritAttrs: !1,
    name: `${o.__name ?? ""}Wrapper`,
    setup(e, n) {
      return () => {
        const s = typeof (t == null ? void 0 : t.props) == "function" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, l = be(), i = T(s, n.attrs);
        return Ve(o, { ...i, ref: l }, n.slots);
      };
    }
  };
}
const wo = g({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(o, { attrs: t, slots: e }) {
    return () => {
      var i, r;
      if (!e.default)
        return null;
      const n = Dt(e.default()), [s, ...l] = n;
      if (Object.keys(t).length > 0) {
        (i = s.props) == null || delete i.ref;
        const u = T(t, s.props ?? {});
        t.class && ((r = s.props) != null && r.class) && delete s.props.class;
        const d = ka(s, u);
        for (const p in u)
          p.startsWith("on") && (d.props || (d.props = {}), d.props[p] = u[p]);
        return n.length === 1 ? d : [d, ...l];
      }
      return n;
    };
  }
}), D = g({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(o, { attrs: t, slots: e }) {
    return (o.asChild ? "template" : o.as) !== "template" ? () => Ve(o.as, t, { default: e.default }) : () => Ve(wo, t, { default: e.default });
  }
});
function F() {
  const o = $(), t = S(() => {
    var e, n;
    return ["#text", "#comment"].includes((e = o.value) == null ? void 0 : e.$el.nodeName) ? (n = o.value) == null ? void 0 : n.$el.nextElementSibling : ve(o);
  });
  return {
    primitiveElement: o,
    currentElement: t
  };
}
const [Pn, _s] = W("CollapsibleRoot"), ws = /* @__PURE__ */ g({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(o, { expose: t, emit: e }) {
    const n = o, l = J(n, "open", e, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), i = J(n, "disabled");
    return _s({
      contentId: te(),
      disabled: i,
      open: l,
      onOpenToggle: () => {
        l.value = !l.value;
      }
    }), t({ open: l }), (r, u) => (h(), b(a(D), {
      as: r.as,
      "as-child": n.asChild,
      "data-state": n.open ? "open" : "closed",
      "data-disabled": n.disabled ? "" : void 0
    }, {
      default: v(() => [
        y(r.$slots, "default", { open: a(l) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state", "data-disabled"]));
  }
}), Es = /* @__PURE__ */ g({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Pn();
    return (n, s) => {
      var l, i;
      return h(), b(a(D), {
        type: n.as === "button" ? "button" : void 0,
        as: n.as,
        "as-child": t.asChild,
        "aria-controls": a(e).contentId,
        "aria-expanded": a(e).open.value,
        "data-state": a(e).open.value ? "open" : "closed",
        "data-disabled": (l = a(e).disabled) != null && l.value ? "" : void 0,
        disabled: (i = a(e).disabled) == null ? void 0 : i.value,
        onClick: a(e).onOpenToggle
      }, {
        default: v(() => [
          y(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
function xs(o, t) {
  const e = $({}), n = $("none"), s = o.value ? "mounted" : "unmounted", { state: l, dispatch: i } = $n(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  X(
    o,
    async (f, m) => {
      var w;
      const C = m !== f;
      if (await Y(), C) {
        const P = n.value, _ = Ct(t.value);
        f ? i("MOUNT") : _ === "none" || ((w = e.value) == null ? void 0 : w.display) === "none" ? i("UNMOUNT") : i(m && P !== _ ? "ANIMATION_OUT" : "UNMOUNT");
      }
    },
    { immediate: !0 }
  );
  const r = (f) => {
    const m = Ct(t.value), C = m.includes(
      f.animationName
    );
    f.target === t.value && C && i("ANIMATION_END"), f.target === t.value && m === "none" && i("ANIMATION_END");
  }, u = (f) => {
    f.target === t.value && (n.value = Ct(t.value));
  }, d = X(
    t,
    (f, m) => {
      f ? (e.value = getComputedStyle(f), f.addEventListener("animationstart", u), f.addEventListener("animationcancel", r), f.addEventListener("animationend", r)) : (i("ANIMATION_END"), m == null || m.removeEventListener("animationstart", u), m == null || m.removeEventListener("animationcancel", r), m == null || m.removeEventListener("animationend", r));
    },
    { immediate: !0 }
  ), p = X(l, () => {
    const f = Ct(t.value);
    n.value = l.value === "mounted" ? f : "none";
  });
  return fe(() => {
    d(), p();
  }), {
    isPresent: S(
      () => ["mounted", "unmountSuspended"].includes(l.value)
    )
  };
}
function Ct(o) {
  return o && getComputedStyle(o).animationName || "none";
}
const se = g({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(o, { slots: t, expose: e }) {
    var d;
    const { present: n, forceMount: s } = U(o), l = $(), { isPresent: i } = xs(n, l);
    e({ present: i });
    let r = t.default({ present: i });
    r = Dt(r || []);
    const u = Le();
    if (r && (r == null ? void 0 : r.length) > 1) {
      const p = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${p}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((c) => `  - ${c}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => s.value || n.value || i.value ? Ve(t.default({ present: i })[0], {
      ref: (p) => {
        const c = ve(p);
        return typeof (c == null ? void 0 : c.hasAttribute) > "u" || (c != null && c.hasAttribute("data-radix-popper-content-wrapper") ? l.value = c.firstElementChild : l.value = c), c;
      }
    }) : null;
  }
}), $s = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Pn(), n = $(), { primitiveElement: s, currentElement: l } = F(), i = $(0), r = $(0), u = S(() => e.open.value), d = $(u.value), p = $();
    return X(
      () => {
        var c;
        return [u.value, (c = n.value) == null ? void 0 : c.present];
      },
      async () => {
        await Y();
        const c = l.value;
        if (!c)
          return;
        p.value = p.value || {
          transitionDuration: c.style.transitionDuration,
          animationName: c.style.animationName
        }, c.style.transitionDuration = "0s", c.style.animationName = "none";
        const f = c.getBoundingClientRect();
        r.value = f.height, i.value = f.width, d.value || (c.style.transitionDuration = p.value.transitionDuration, c.style.animationName = p.value.animationName);
      },
      {
        immediate: !0
      }
    ), q(() => {
      requestAnimationFrame(() => {
        d.value = !1;
      });
    }), (c, f) => (h(), b(a(se), {
      ref_key: "presentRef",
      ref: n,
      present: c.forceMount || a(e).open.value,
      "force-mount": !0
    }, {
      default: v(() => {
        var m, C;
        return [
          M(a(D), T(c.$attrs, {
            id: a(e).contentId,
            ref_key: "primitiveElement",
            ref: s,
            "as-child": t.asChild,
            as: c.as,
            "data-state": a(e).open.value ? "open" : "closed",
            "data-disabled": (m = a(e).disabled) != null && m.value ? "true" : void 0,
            hidden: !((C = n.value) != null && C.present),
            style: {
              "--radix-collapsible-content-height": `${r.value}px`,
              "--radix-collapsible-content-width": `${i.value}px`
            }
          }), {
            default: v(() => {
              var w;
              return [
                (w = n.value) != null && w.present ? y(c.$slots, "default", { key: 0 }) : G("", !0)
              ];
            }),
            _: 3
          }, 16, ["id", "as-child", "as", "data-state", "data-disabled", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
function Ps(o, t) {
  if (o === "single") {
    if (Array.isArray(t)) {
      console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`value\` prop must be:
  - a string
  - \`undefined\`

If you want to use multiple values, use the \`AccordionRoot\` with type \`multiple\`.

Defaulting to \`undefined\`.`);
      return;
    }
  } else if (o === "multiple" && (typeof t == "string" || typeof t > "u"))
    return console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`value\` prop must be:
- an array of strings
- empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`), [];
  return t;
}
function Bs({ type: o, defaultValue: t }) {
  if (o === "multiple")
    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`defaultValue\` prop must be:
  - an array of strings
  - empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`
    ), []);
  if (o === "single") {
    if (typeof t == "string")
      return t;
    if (t === void 0)
      return;
    console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`defaultValue\` prop must be:
  - a string
  - \`undefined\`

Defaulting to \`undefined\`.`
    );
    return;
  }
}
function Bn(o, t) {
  const e = J(o, "modelValue", t, {
    defaultValue: Bs(o),
    passive: o.modelValue === void 0
  });
  X(
    () => [o.type, o.modelValue],
    () => {
      const s = Ps(o.type, e.value);
      e.value !== s && (e.value = s);
    },
    { immediate: !0 }
  );
  function n(s) {
    if (o.type === "single")
      e.value = s === e.value ? void 0 : s;
    else {
      const l = e.value || [];
      if (l.includes(s)) {
        const i = l.findIndex((r) => r === s);
        l.splice(i, 1);
      } else
        l.push(s);
      e.value = l, t("update:modelValue", e.value);
    }
  }
  return {
    modelValue: e,
    changeModelValue: n
  };
}
const [It, Ss] = W("AccordionRoot"), Jr = /* @__PURE__ */ g({
  __name: "AccordionRoot",
  props: {
    type: {},
    modelValue: {},
    defaultValue: {},
    collapsible: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dir: {},
    orientation: { default: "vertical" },
    asChild: { type: Boolean, default: !1 },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { expose: t, emit: e }) {
    const n = o, s = e, { dir: l, disabled: i } = U(n), r = de(l), { modelValue: u, changeModelValue: d } = Bn(n, s), { primitiveElement: p, currentElement: c } = F();
    return Ss({
      disabled: i,
      direction: r,
      orientation: n.orientation,
      parentElement: c,
      isSingle: S(() => n.type === "single"),
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d
    }), t({
      modelValue: u
    }), (f, m) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: p,
      "as-child": f.asChild,
      as: f.as
    }, {
      default: v(() => [
        y(f.$slots, "default", { modelValue: a(u) })
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), [Eo, Ts] = W("AccordionItem"), Zr = /* @__PURE__ */ g({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, n = It(), s = S(
      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)
    ), l = S(() => n.disabled.value || e.disabled || n.isSingle.value && s.value && !n.collapsible), i = S(() => l.value ? "" : void 0), r = S(
      () => s.value ? "open" : "closed"
      /* Closed */
    ), { primitiveElement: u, currentElement: d } = F();
    Ts({
      open: s,
      dataState: r,
      disabled: l,
      dataDisabled: i,
      triggerId: te(),
      primitiveElement: u,
      currentElement: d,
      value: S(() => e.value)
    });
    function p(c) {
      Ye(
        c,
        d.value,
        n.parentElement.value,
        {
          arrowKeyOptions: n.orientation,
          dir: n.direction.value,
          focus: !0
        }
      );
    }
    return t({ open: s }), (c, f) => (h(), b(a(ws), {
      "data-orientation": a(n).orientation,
      "data-disabled": i.value,
      "data-state": r.value,
      disabled: l.value,
      open: s.value,
      "as-child": e.asChild,
      onKeydown: le(p, ["up", "down", "left", "right", "home", "end"])
    }, {
      default: v(() => [
        y(c.$slots, "default", { open: s.value })
      ]),
      _: 3
    }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as-child"]));
  }
}), Qr = /* @__PURE__ */ g({
  __name: "AccordionContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = It(), n = Eo();
    return (s, l) => (h(), b(a($s), {
      id: a(n).triggerId,
      role: "region",
      open: a(n).open.value,
      hidden: !a(n).open.value,
      "as-child": t.asChild,
      "aria-labelledby": a(n).triggerId,
      "data-state": a(n).dataState.value,
      "data-disabled": a(n).dataDisabled.value,
      "data-orientation": a(e).orientation,
      style: { "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", "--radix-accordion-content-height": "var(--radix-collapsible-content-height)" }
    }, {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "open", "hidden", "as-child", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]));
  }
}), eu = /* @__PURE__ */ g({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(o) {
    const t = o, e = It(), n = Eo();
    return (s, l) => (h(), b(a(D), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": a(e).orientation,
      "data-state": a(n).dataState.value,
      "data-disabled": a(n).dataDisabled.value
    }, {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]));
  }
}), tu = /* @__PURE__ */ g({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = It(), n = Eo();
    function s() {
      n.disabled.value || e.changeModelValue(n.value.value);
    }
    return (l, i) => (h(), b(a(Es), {
      id: a(n).triggerId,
      ref: a(n).primitiveElement,
      "data-radix-vue-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-controls": a(n).triggerId,
      "aria-disabled": a(n).disabled.value || void 0,
      "aria-expanded": a(n).open.value || !1,
      "data-disabled": a(n).dataDisabled.value,
      "data-orientation": a(e).orientation,
      "data-state": a(n).dataState.value,
      disabled: a(n).disabled.value,
      onClick: s
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "aria-controls", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]));
  }
}), [ye, Ds] = W("DialogRoot"), Os = /* @__PURE__ */ g({
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), l = $(), i = $(), { modal: r } = U(e);
    return Ds({
      open: s,
      modal: r,
      openModal: () => {
        s.value = !0;
      },
      onOpenChange: (u) => {
        s.value = u;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      contentId: te(),
      titleId: te(),
      descriptionId: te(),
      triggerElement: l,
      contentElement: i
    }), (u, d) => y(u.$slots, "default");
  }
}), Is = /* @__PURE__ */ g({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ye(), { primitiveElement: n, currentElement: s } = F();
    return q(() => {
      e.triggerElement = s;
    }), (l, i) => (h(), b(a(D), T({
      ref_key: "primitiveElement",
      ref: n
    }, t, {
      type: l.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": a(e).open.value || !1,
      "aria-controls": a(e).contentId,
      "data-state": a(e).open.value ? "open" : "closed",
      onClick: a(e).onOpenToggle
    }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]));
  }
}), Te = /* @__PURE__ */ g({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = Tt();
    return (e, n) => a(t) || e.forceMount ? (h(), b(Ge, {
      key: 0,
      to: e.to,
      disabled: e.disabled
    }, [
      y(e.$slots, "default")
    ], 8, ["to", "disabled"])) : G("", !0);
  }
}), ou = /* @__PURE__ */ g({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), As = "dismissableLayer.pointerDownOutside", Ms = "dismissableLayer.focusOutside";
function Sn(o, t) {
  const e = t.closest(
    "[data-dismissable-layer]"
  ), n = o.querySelector(
    "[data-dismissable-layer]"
  ), s = Array.from(
    o.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(e && n === e || s.indexOf(n) < s.indexOf(e));
}
function ks(o, t) {
  var l;
  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = $(!1), s = $(() => {
  });
  return Q((i) => {
    if (!Ee)
      return;
    const r = async (d) => {
      if (t != null && t.value) {
        if (Sn(t.value, d.target)) {
          n.value = !1;
          return;
        }
        if (d.target && !n.value) {
          let p = function() {
            fo(
              As,
              o,
              c
            );
          };
          const c = { originalEvent: d };
          d.pointerType === "touch" ? (e.removeEventListener("click", s.value), s.value = p, e.addEventListener("click", s.value, {
            once: !0
          })) : p();
        } else
          e.removeEventListener("click", s.value);
        n.value = !1;
      }
    }, u = window.setTimeout(() => {
      e.addEventListener("pointerdown", r);
    }, 0);
    i(() => {
      window.clearTimeout(u), e.removeEventListener("pointerdown", r), e.removeEventListener("click", s.value);
    });
  }), {
    onPointerDownCapture: () => n.value = !0
  };
}
function Rs(o, t) {
  var s;
  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = $(!1);
  return Q((l) => {
    if (!Ee)
      return;
    const i = async (r) => {
      t != null && t.value && (await Y(), !Sn(t.value, r.target) && r.target && !n.value && fo(
        Ms,
        o,
        { originalEvent: r }
      ));
    };
    e.addEventListener("focusin", i), l(() => e.removeEventListener("focusin", i));
  }), {
    onFocusCapture: () => n.value = !0,
    onBlurCapture: () => n.value = !1
  };
}
const he = hn({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), De = /* @__PURE__ */ g({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: l } = F(), i = S(
      () => {
        var C;
        return ((C = l.value) == null ? void 0 : C.ownerDocument) ?? globalThis.document;
      }
    ), r = S(() => he.layersRoot), u = S(() => l.value ? Array.from(r.value).indexOf(l.value) : -1), d = S(() => he.layersWithOutsidePointerEventsDisabled.size > 0), p = S(() => {
      const C = Array.from(r.value), [w] = [...he.layersWithOutsidePointerEventsDisabled].slice(-1), P = C.indexOf(w);
      return u.value >= P;
    }), c = ks(async (C) => {
      const w = [...he.branches].some(
        (P) => P.contains(C.target)
      );
      !p.value || w || (n("pointerDownOutside", C), n("interactOutside", C), await Y(), C.defaultPrevented || n("dismiss"));
    }, l), f = Rs((C) => {
      [...he.branches].some(
        (P) => P.contains(C.target)
      ) || (n("focusOutside", C), n("interactOutside", C), C.defaultPrevented || n("dismiss"));
    }, l);
    go("Escape", (C) => {
      u.value === r.value.size - 1 && (n("escapeKeyDown", C), C.defaultPrevented || n("dismiss"));
    });
    let m;
    return Q((C) => {
      l.value && (e.disableOutsidePointerEvents && (he.layersWithOutsidePointerEventsDisabled.size === 0 && (m = i.value.body.style.pointerEvents, i.value.body.style.pointerEvents = "none"), he.layersWithOutsidePointerEventsDisabled.add(l.value)), r.value.add(l.value), C(() => {
        e.disableOutsidePointerEvents && he.layersWithOutsidePointerEventsDisabled.size === 1 && (i.value.body.style.pointerEvents = m);
      }));
    }), Q((C) => {
      C(() => {
        l.value && (r.value.delete(l.value), he.layersWithOutsidePointerEventsDisabled.delete(l.value));
      });
    }), (C, w) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: s,
      "as-child": C.asChild,
      as: C.as,
      "data-dismissable-layer": "",
      style: ae({
        pointerEvents: d.value ? p.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: a(f).onFocusCapture,
      onBlurCapture: a(f).onBlurCapture,
      onPointerdownCapture: a(c).onPointerDownCapture
    }, {
      default: v(() => [
        y(C.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), Vs = /* @__PURE__ */ g({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = F();
    return q(() => {
      he.branches.add(n.value);
    }), fe(() => {
      he.branches.delete(n.value);
    }), (s, l) => (h(), b(a(D), T({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qt = "focusScope.autoFocusOnMount", eo = "focusScope.autoFocusOnUnmount", nn = { bubbles: !1, cancelable: !0 };
function xt(o, { select: t = !1 } = {}) {
  const e = document.activeElement;
  for (const n of o)
    if (Be(n, { select: t }), document.activeElement !== e)
      return !0;
}
function Fs(o) {
  const t = xo(o), e = an(t, o), n = an(t.reverse(), o);
  return [e, n];
}
function xo(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const s = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function an(o, t) {
  for (const e of o)
    if (!Ls(e, { upTo: t }))
      return e;
}
function Ls(o, { upTo: t }) {
  if (getComputedStyle(o).visibility === "hidden")
    return !0;
  for (; o; ) {
    if (t !== void 0 && o === t)
      return !1;
    if (getComputedStyle(o).display === "none")
      return !0;
    o = o.parentElement;
  }
  return !1;
}
function Ks(o) {
  return o instanceof HTMLInputElement && "select" in o;
}
function Be(o, { select: t = !1 } = {}) {
  if (o && o.focus) {
    const e = document.activeElement;
    o.focus({ preventScroll: !0 }), o !== e && Ks(o) && t && o.select();
  }
}
const Ns = St(() => $([]));
function Hs() {
  const o = Ns();
  return {
    add(t) {
      const e = o.value[0];
      t !== e && (e == null || e.pause()), o.value = sn(o.value, t), o.value.unshift(t);
    },
    remove(t) {
      var e;
      o.value = sn(o.value, t), (e = o.value[0]) == null || e.resume();
    }
  };
}
function sn(o, t) {
  const e = [...o], n = e.indexOf(t);
  return n !== -1 && e.splice(n, 1), e;
}
function Ws(o) {
  return o.filter((t) => t.tagName !== "A");
}
const At = /* @__PURE__ */ g({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: l } = F(), i = $(null), r = Hs(), u = hn({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    Q((p) => {
      if (!Ee)
        return;
      const c = l.value;
      if (!e.trapped)
        return;
      function f(P) {
        if (u.paused || !c)
          return;
        const _ = P.target;
        c.contains(_) ? i.value = _ : Be(i.value, { select: !0 });
      }
      function m(P) {
        if (u.paused || !c)
          return;
        const _ = P.relatedTarget;
        _ !== null && (c.contains(_) || Be(i.value, { select: !0 }));
      }
      function C(P) {
        c.contains(i.value) || Be(c);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", m);
      const w = new MutationObserver(C);
      c && w.observe(c, { childList: !0, subtree: !0 }), p(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", m), w.disconnect();
      });
    }), Q(async (p) => {
      const c = l.value;
      if (await Y(), !c)
        return;
      r.add(u);
      const f = document.activeElement;
      if (!c.contains(f)) {
        const C = new CustomEvent(Qt, nn);
        c.addEventListener(
          Qt,
          (w) => n("mountAutoFocus", w)
        ), c.dispatchEvent(C), C.defaultPrevented || (xt(Ws(xo(c)), {
          select: !0
        }), document.activeElement === f && Be(c));
      }
      p(() => {
        c.removeEventListener(
          Qt,
          (P) => n("mountAutoFocus", P)
        );
        const C = new CustomEvent(eo, nn), w = (P) => {
          n("unmountAutoFocus", P);
        };
        c.addEventListener(eo, w), c.dispatchEvent(C), setTimeout(() => {
          C.defaultPrevented || Be(f ?? document.body, { select: !0 }), c.removeEventListener(eo, w), r.remove(u);
        }, 0);
      });
    });
    function d(p) {
      if (!e.loop && !e.trapped || u.paused)
        return;
      const c = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, f = document.activeElement;
      if (c && f) {
        const m = p.currentTarget, [C, w] = Fs(m);
        C && w ? !p.shiftKey && f === w ? (p.preventDefault(), e.loop && Be(C, { select: !0 })) : p.shiftKey && f === C && (p.preventDefault(), e.loop && Be(w, { select: !0 })) : f === m && p.preventDefault();
      }
    }
    return (p, c) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: s,
      tabindex: "-1",
      "as-child": e.asChild,
      as: e.as,
      onKeydown: d
    }, {
      default: v(() => [
        y(p.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), js = "menu.itemSelect", oo = ["Enter", " "], zs = ["ArrowDown", "PageUp", "Home"], Tn = ["ArrowUp", "PageDown", "End"], Us = [...zs, ...Tn], qs = {
  ltr: [...oo, "ArrowRight"],
  rtl: [...oo, "ArrowLeft"]
}, Gs = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function $o(o) {
  return o ? "open" : "closed";
}
function Pt(o) {
  return o === "indeterminate";
}
function Po(o) {
  return Pt(o) ? "indeterminate" : o ? "checked" : "unchecked";
}
function no(o) {
  const t = document.activeElement;
  for (const e of o)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function Ys(o, t) {
  const { x: e, y: n } = o;
  let s = !1;
  for (let l = 0, i = t.length - 1; l < t.length; i = l++) {
    const r = t[l].x, u = t[l].y, d = t[i].x, p = t[i].y;
    u > n != p > n && e < (d - r) * (n - u) / (p - u) + r && (s = !s);
  }
  return s;
}
function Xs(o, t) {
  if (!t)
    return !1;
  const e = { x: o.clientX, y: o.clientY };
  return Ys(e, t);
}
function st(o) {
  return o.pointerType === "mouse";
}
function Js() {
  const o = "DialogContent", t = "DialogTitle", e = ye(), n = `Warning: \`${o}\` requires a \`${t}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.radix-vue.com/components/dialog.html#title;`, s = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${o}.`;
  q(() => {
    var r;
    document.getElementById(e.titleId) || console.warn(n);
    const i = (r = e.contentElement.value) == null ? void 0 : r.getAttribute("aria-describedby");
    e.descriptionId && i && (document.getElementById(e.descriptionId) || console.warn(s));
  });
}
const Dn = /* @__PURE__ */ g({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), { primitiveElement: l, currentElement: i } = F();
    return q(() => {
      s.contentElement = i;
    }), process.env.NODE_ENV !== "production" && Js(), (r, u) => (h(), b(a(At), {
      "as-child": "",
      loop: "",
      trapped: e.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => n("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => n("closeAutoFocus", d))
    }, {
      default: v(() => [
        M(a(De), T({
          id: a(s).contentId,
          ref_key: "primitiveElement",
          ref: l,
          as: r.as,
          "as-child": r.asChild,
          "disable-outside-pointer-events": r.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": a(s).descriptionId,
          "aria-labelledby": a(s).titleId,
          "data-state": a($o)(a(s).open.value)
        }, r.$attrs, {
          onDismiss: u[0] || (u[0] = (d) => a(s).onOpenChange(!1)),
          onEscapeKeyDown: u[1] || (u[1] = (d) => n("escapeKeyDown", d)),
          onFocusOutside: u[2] || (u[2] = (d) => n("focusOutside", d)),
          onInteractOutside: u[3] || (u[3] = (d) => n("interactOutside", d)),
          onPointerDownOutside: u[4] || (u[4] = (d) => n("pointerDownOutside", d))
        }), {
          default: v(() => [
            y(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Zs = /* @__PURE__ */ g({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), l = ce(n), { primitiveElement: i, currentElement: r } = F();
    return ft(r), (u, d) => (h(), b(Dn, T({
      ref_key: "primitiveElement",
      ref: i
    }, { ...e, ...a(l) }, {
      "trap-focus": a(s).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (p.preventDefault(), (c = a(s).triggerElement.value) == null || c.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (p) => {
        const c = p.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
        (c.button === 2 || f) && p.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (p) => {
        p.preventDefault();
      }),
      onOpenAutoFocus: d[3] || (d[3] = (p) => n("openAutoFocus", p))
    }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), Qs = /* @__PURE__ */ g({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ce(n), l = ye(), i = $(!1), r = $(!1);
    return (u, d) => (h(), b(Dn, T({ ...e, ...a(s) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (i.value || (c = a(l).triggerElement.value) == null || c.focus(), p.preventDefault()), i.value = !1, r.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = (p) => {
        var m;
        p.defaultPrevented || (i.value = !0, p.detail.originalEvent.type === "pointerdown" && (r.value = !0));
        const c = p.target;
        ((m = a(l).triggerElement.value) == null ? void 0 : m.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === "focusin" && r.value && p.preventDefault();
      })
    }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), el = /* @__PURE__ */ g({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), l = ce(n);
    return (i, r) => (h(), b(a(se), {
      present: i.forceMount || a(s).open.value
    }, {
      default: v(() => [
        a(s).modal.value ? (h(), b(Zs, T({ key: 0 }, { ...e, ...a(l), ...i.$attrs }, {
          onOpenAutoFocus: r[0] || (r[0] = (u) => n("openAutoFocus", u))
        }), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (h(), b(Qs, R(T({ key: 1 }, { ...e, ...a(l), ...i.$attrs })), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), tl = /* @__PURE__ */ g({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = ye();
    return pt(!0), (e, n) => (h(), b(a(D), {
      as: e.as,
      "as-child": e.asChild,
      "data-state": a(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), ol = /* @__PURE__ */ g({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = ye();
    return (e, n) => {
      var s;
      return (s = a(t)) != null && s.modal.value ? (h(), b(a(se), {
        key: 0,
        present: e.forceMount || a(t).open.value
      }, {
        default: v(() => [
          M(tl, T({
            as: e.as,
            "as-child": e.asChild
          }, e.$attrs), {
            default: v(() => [
              y(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : G("", !0);
    };
  }
}), On = /* @__PURE__ */ g({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (h(), b(a(D), T(t, {
      type: n.as === "button" ? "button" : void 0,
      onClick: s[0] || (s[0] = (l) => a(e).onOpenChange(!1))
    }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), nl = /* @__PURE__ */ g({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (h(), b(a(D), T(t, {
      id: a(e).titleId
    }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), al = /* @__PURE__ */ g({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (h(), b(a(D), T(t, {
      id: a(e).descriptionId
    }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), nu = /* @__PURE__ */ g({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const s = pe(o, t);
    return (l, i) => (h(), b(a(Os), T(a(s), { modal: !0 }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), au = /* @__PURE__ */ g({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Is), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), su = /* @__PURE__ */ g({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [sl, ll] = W("AlertDialogContent"), lu = /* @__PURE__ */ g({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t), l = $();
    return ll({
      onCancelElementChange: (i) => {
        l.value = i;
      }
    }), (i, r) => (h(), b(a(el), T({ ...e, ...a(s) }, {
      role: "alertdialog",
      onPointerDownOutside: r[0] || (r[0] = oe(() => {
      }, ["prevent"])),
      onInteractOutside: r[1] || (r[1] = oe(() => {
      }, ["prevent"])),
      onOpenAutoFocus: r[2] || (r[2] = () => {
        Y(() => {
          var u;
          (u = l.value) == null || u.focus({
            preventScroll: !0
          });
        });
      })
    }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), iu = /* @__PURE__ */ g({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(ol), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ru = /* @__PURE__ */ g({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = sl(), { primitiveElement: n, currentElement: s } = F();
    return q(() => {
      e.onCancelElementChange(s.value);
    }), (l, i) => (h(), b(a(On), T(t, {
      ref_key: "primitiveElement",
      ref: n
    }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), uu = /* @__PURE__ */ g({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(nl), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), du = /* @__PURE__ */ g({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(al), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cu = /* @__PURE__ */ g({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(On), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pu = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "AspectRatio",
  props: {
    ratio: { default: 1 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = S(() => 1 / t.ratio * 100);
    return (n, s) => (h(), Z("div", {
      style: ae(`position: relative; width: 100%; padding-bottom: ${e.value}%`),
      "data-radix-aspect-ratio-wrapper": ""
    }, [
      M(a(D), T({
        "as-child": n.asChild,
        as: n.as,
        style: { position: "absolute", inset: "0px" }
      }, n.$attrs), {
        default: v(() => [
          y(n.$slots, "default", { aspect: e.value })
        ]),
        _: 3
      }, 16, ["as-child", "as"])
    ], 4));
  }
}), [In, il] = W("AvatarRoot"), fu = /* @__PURE__ */ g({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o;
    return il({
      imageLoadingStatus: $("loading")
    }), (e, n) => (h(), b(a(D), {
      as: e.as,
      "as-child": t.asChild
    }, {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function rl(o) {
  const t = $("idle"), e = $(!1), n = (s) => () => {
    e.value && (t.value = s);
  };
  return q(() => {
    e.value = !0, X(o, (s) => {
      if (!s)
        t.value = "error";
      else {
        const l = new window.Image();
        t.value = "loading", l.onload = n("loaded"), l.onerror = n("error"), l.src = s;
      }
    }, { immediate: !0 });
  }), fe(() => {
    e.value = !1;
  }), t;
}
const vu = /* @__PURE__ */ g({
  __name: "AvatarImage",
  props: {
    src: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(o, { emit: t }) {
    const e = o, n = t, { src: s } = U(e), l = In(), i = rl(s);
    return X(
      i,
      (r) => {
        n("loadingStatusChange", r), r !== "idle" && (l.imageLoadingStatus.value = r);
      },
      { immediate: !0 }
    ), (r, u) => a(i) === "loaded" ? (h(), b(a(D), {
      key: 0,
      role: "img",
      "as-child": r.asChild,
      as: r.as,
      src: a(s)
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "src"])) : G("", !0);
  }
}), mu = /* @__PURE__ */ g({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = In(), n = $(!1);
    let s;
    return X(e.imageLoadingStatus, (l) => {
      l === "loading" && (n.value = !1, t.delayMs ? s = setTimeout(() => {
        n.value = !0, clearTimeout(s);
      }, t.delayMs) : n.value = !0);
    }, { immediate: !0 }), (l, i) => n.value && a(e).imageLoadingStatus.value !== "loaded" ? (h(), b(a(D), {
      key: 0,
      "as-child": t.asChild,
      as: l.as
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"])) : G("", !0);
  }
});
function Bo(o) {
  return o === "indeterminate";
}
function An(o) {
  return Bo(o) ? "indeterminate" : o ? "checked" : "unchecked";
}
const ul = ["value", "checked", "name", "disabled", "required"], [dl, cl] = W("CheckboxRoot"), hu = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String], default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = U(e), l = J(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    }), { primitiveElement: i, currentElement: r } = F(), u = Ne(r), d = S(() => {
      var p;
      return e.id && r.value ? (p = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : p.innerText : void 0;
    });
    return cl({
      disabled: s,
      state: l
    }), (p, c) => (h(), Z(ie, null, [
      M(a(D), T(p.$attrs, {
        id: p.id,
        ref_key: "primitiveElement",
        ref: i,
        role: "checkbox",
        "as-child": e.asChild,
        as: p.as,
        type: p.as === "button" ? "button" : void 0,
        "aria-checked": a(Bo)(a(l)) ? "mixed" : a(l),
        "aria-required": !1,
        "aria-label": p.$attrs["aria-label"] || d.value,
        "data-state": a(An)(a(l)),
        "data-disabled": a(s) ? "" : void 0,
        disabled: a(s),
        onKeydown: le(oe(() => {
        }, ["prevent"]), ["enter"]),
        onClick: c[0] || (c[0] = (f) => l.value = !a(l))
      }), {
        default: v(() => [
          y(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-label", "data-state", "data-disabled", "disabled", "onKeydown"]),
      a(u) ? (h(), Z("input", {
        key: 0,
        type: "checkbox",
        tabindex: "-1",
        "aria-hidden": "",
        value: p.value,
        checked: !!a(l),
        name: e.name,
        disabled: e.disabled,
        required: e.required,
        style: ae({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, ul)) : G("", !0)
    ], 64));
  }
}), yu = /* @__PURE__ */ g({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = dl();
    return (e, n) => (h(), b(a(se), {
      present: e.forceMount || a(Bo)(a(t).state.value) || a(t).state.value === !0
    }, {
      default: v(() => [
        M(a(D), T({
          "data-state": a(An)(a(t).state.value),
          "data-disabled": a(t).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": e.asChild,
          as: e.as
        }, e.$attrs), {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Mn, pl] = W("PopperRoot"), He = /* @__PURE__ */ g({
  __name: "PopperRoot",
  setup(o) {
    const t = $();
    return pl({
      anchor: t,
      onAnchorChange: (e) => t.value = e
    }), (e, n) => y(e.$slots, "default");
  }
}), We = /* @__PURE__ */ g({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = F(), s = Mn();
    return X(n, () => {
      s.onAnchorChange(t.element ?? n.value);
    }), (l, i) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: e,
      as: l.as,
      "as-child": l.asChild
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function fl(o) {
  return o !== null;
}
function vl(o) {
  return {
    name: "transformOrigin",
    options: o,
    fn(t) {
      var P, _, E;
      const { placement: e, rects: n, middlewareData: s } = t, i = ((P = s.arrow) == null ? void 0 : P.centerOffset) !== 0, r = i ? 0 : o.arrowWidth, u = i ? 0 : o.arrowHeight, [d, p] = ao(e), c = { start: "0%", center: "50%", end: "100%" }[p], f = (((_ = s.arrow) == null ? void 0 : _.x) ?? 0) + r / 2, m = (((E = s.arrow) == null ? void 0 : E.y) ?? 0) + u / 2;
      let C = "", w = "";
      return d === "bottom" ? (C = i ? c : `${f}px`, w = `${-u}px`) : d === "top" ? (C = i ? c : `${f}px`, w = `${n.floating.height + u}px`) : d === "right" ? (C = `${-u}px`, w = i ? c : `${m}px`) : d === "left" && (C = `${n.floating.width + u}px`, w = i ? c : `${m}px`), { data: { x: C, y: w } };
    }
  };
}
function ao(o) {
  const [t, e = "center"] = o.split("-");
  return [t, e];
}
const kn = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [ml, hl] = W("PopperContent"), Fe = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ yn({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...kn
  }),
  setup(o, { expose: t }) {
    const e = o, n = Mn(), s = be(), { primitiveElement: l, currentElement: i } = F(), r = $(), u = $(), { width: d, height: p } = xn(u), c = S(
      () => e.side + (e.align !== "center" ? `-${e.align}` : "")
    ), f = S(() => typeof e.collisionPadding == "number" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), m = S(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), C = S(() => ({
      padding: f.value,
      boundary: m.value.filter(fl),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: m.value.length > 0
    })), w = Ua(() => [
      La({
        mainAxis: e.sideOffset + p.value,
        alignmentAxis: e.alignOffset
      }),
      e.avoidCollisions && Ka({
        mainAxis: !0,
        crossAxis: !!e.prioritizePosition,
        limiter: e.sticky === "partial" ? Na() : void 0,
        ...C.value
      }),
      !e.prioritizePosition && e.avoidCollisions && Ha({
        ...C.value
      }),
      Wa({
        ...C.value,
        apply: ({ elements: O, rects: H, availableWidth: j, availableHeight: L }) => {
          const { width: z, height: ee } = H.reference, ne = O.floating.style;
          Object.assign(O.floating.style, {
            maxWidth: `${j}px`,
            maxHeight: `${L}px`
          }), ne.setProperty(
            "--radix-popper-available-width",
            `${j}px`
          ), ne.setProperty(
            "--radix-popper-available-height",
            `${L}px`
          ), ne.setProperty(
            "--radix-popper-anchor-width",
            `${z}px`
          ), ne.setProperty(
            "--radix-popper-anchor-height",
            `${ee}px`
          );
        }
      }),
      u.value && ja({ element: u.value, padding: e.arrowPadding }),
      vl({
        arrowWidth: d.value,
        arrowHeight: p.value
      }),
      e.hideWhenDetached && za({ strategy: "referenceHidden", ...C.value })
    ]), { floatingStyles: P, placement: _, isPositioned: E, middlewareData: x } = Va(
      n.anchor,
      r,
      {
        strategy: "fixed",
        placement: c,
        whileElementsMounted: (...O) => Fa(...O, {
          animationFrame: e.updatePositionStrategy === "always"
        }),
        middleware: w
      }
    ), B = S(
      () => ao(_.value)[0]
    ), I = S(
      () => ao(_.value)[1]
    );
    Q(() => {
      var O;
      E.value && ((O = e.onPlaced) == null || O.call(e));
    });
    const A = S(
      () => {
        var O;
        return ((O = x.value.arrow) == null ? void 0 : O.centerOffset) !== 0;
      }
    ), V = $("");
    Q(() => {
      i.value && (V.value = window.getComputedStyle(i.value).zIndex);
    });
    const k = S(() => {
      var O;
      return ((O = x.value.arrow) == null ? void 0 : O.x) ?? 0;
    }), N = S(() => {
      var O;
      return ((O = x.value.arrow) == null ? void 0 : O.y) ?? 0;
    });
    return hl({
      placedSide: B,
      onArrowChange: (O) => u.value = O,
      arrowX: k,
      arrowY: N,
      shouldHideArrow: A
    }), t({
      $el: i
    }), (O, H) => {
      var j, L, z;
      return h(), Z("div", {
        ref_key: "floatingRef",
        ref: r,
        "data-radix-popper-content-wrapper": "",
        style: ae({
          ...a(P),
          transform: a(E) ? a(P).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: V.value,
          "--radix-popper-transform-origin": [
            (j = a(x).transformOrigin) == null ? void 0 : j.x,
            (L = a(x).transformOrigin) == null ? void 0 : L.y
          ].join(" ")
        })
      }, [
        M(a(D), T({
          ref: (ee) => {
            a(s)(ee), l.value = ee;
          }
        }, O.$attrs, {
          "as-child": e.asChild,
          as: O.as,
          "data-side": B.value,
          "data-align": I.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: a(E) ? void 0 : "none",
            // hide the content if using the hide middleware and should be hidden
            opacity: (z = a(x).hide) != null && z.referenceHidden ? 0 : void 0
          }
        }), {
          default: v(() => [
            y(O.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
}), yl = /* @__PURE__ */ rt("polygon", { points: "0,0 30,0 15,10" }, null, -1), gl = /* @__PURE__ */ g({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(o) {
    const t = o, { primitiveElement: e } = F();
    return (n, s) => (h(), b(a(D), T({
      ref_key: "primitiveElement",
      ref: e
    }, t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 30 10",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: v(() => [
        y(n.$slots, "default", {}, () => [
          yl
        ])
      ]),
      _: 3
    }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]));
  }
}), bl = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Xe = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(o) {
    const t = ml(), e = S(() => bl[t.placedSide.value]);
    return (n, s) => {
      var l, i, r, u;
      return h(), Z("span", {
        ref: (d) => {
          a(t).onArrowChange(d);
        },
        style: ae({
          position: "absolute",
          left: (l = a(t).arrowX) != null && l.value ? `${(i = a(t).arrowX) == null ? void 0 : i.value}px` : void 0,
          top: (r = a(t).arrowY) != null && r.value ? `${(u = a(t).arrowY) == null ? void 0 : u.value}px` : void 0,
          [e.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a(t).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a(t).placedSide.value],
          visibility: a(t).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        M(gl, T(n.$attrs, {
          style: {
            display: "block"
          },
          as: n.as,
          "as-child": n.asChild,
          width: n.width,
          height: n.height
        }), {
          default: v(() => [
            y(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "width", "height"])
      ], 4);
    };
  }
}), Je = /* @__PURE__ */ g({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    return (t, e) => (h(), b(a(D), {
      as: t.as,
      "as-child": t.asChild,
      style: ae({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        display: "inline-block",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      })
    }, {
      default: v(() => [
        y(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "style"]));
  }
}), Rn = /* @__PURE__ */ g({
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    required: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(o) {
    const t = o, e = S(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((n, s) => typeof n == "object" ? Object.entries(n).map(([l, i]) => ({ name: `[${s}][${t.name}][${l}]`, value: i })) : { name: `[${t.name}][${s}]`, value: n }) : typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, s]) => ({ name: `[${t.name}][${n}]`, value: s })) : []);
    return (n, s) => (h(!0), Z(ie, null, co(e.value, (l) => (h(), b(Je, {
      key: l.name,
      as: "input",
      type: "hidden",
      hidden: "",
      readonly: "",
      name: l.name,
      value: l.value,
      required: n.required,
      disabled: n.disabled
    }, null, 8, ["name", "value", "required", "disabled"]))), 128));
  }
});
function Cl(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
var _l = function o(t, e) {
  if (t === e)
    return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor)
      return !1;
    var n, s, l;
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length)
        return !1;
      for (s = n; s-- !== 0; )
        if (!o(t[s], e[s]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === e.toString();
    if (l = Object.keys(t), n = l.length, n !== Object.keys(e).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, l[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      var i = l[s];
      if (!o(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
};
const nt = /* @__PURE__ */ Cl(_l), wl = "data-radix-vue-collection-item", [So, El] = W("CollectionProvider");
function Vn(o = wl) {
  const t = $(/* @__PURE__ */ new Map()), e = $(), n = El({
    collectionRef: e,
    itemMap: t,
    attrName: o
  }), { getItems: s } = xl(n), l = S(() => Array.from(n.itemMap.value.values())), i = S(() => n.itemMap.value.size);
  return { getItems: s, reactiveItems: l, itemMapSize: i };
}
const Fn = g({
  name: "CollectionSlot",
  setup(o, { slots: t }) {
    const e = So(), { primitiveElement: n, currentElement: s } = F();
    return X(s, () => {
      e.collectionRef.value = s.value;
    }), () => Ve(wo, { ref: n }, t);
  }
}), Ln = g({
  name: "CollectionItem",
  setup(o, { slots: t, attrs: e }) {
    const n = So(), { primitiveElement: s, currentElement: l } = F(), i = Le();
    return Q((r) => {
      var u;
      if (l.value) {
        const d = Qo(l.value);
        n.itemMap.value.set(d, { ref: l.value, ...Qo(((u = i == null ? void 0 : i.parent) == null ? void 0 : u.props) ?? {}) }), r(() => n.itemMap.value.delete(d));
      }
    }), () => Ve(wo, { ...e, [n.attrName]: "", ref: s }, t);
  }
});
function xl(o) {
  const t = o ?? So();
  return { getItems: () => {
    const n = t.collectionRef.value;
    if (!n)
      return [];
    const s = Array.from(n.querySelectorAll(`[${t.attrName}]`));
    return Array.from(t.itemMap.value.values()).sort(
      (r, u) => s.indexOf(r.ref) - s.indexOf(u.ref)
    );
  } };
}
const [xe, $l] = W("ComboboxRoot"), gu = /* @__PURE__ */ g({
  __name: "ComboboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    displayValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm"],
  setup(o, { emit: t }) {
    const e = o, n = t, { multiple: s, disabled: l, dir: i } = U(e), r = de(i), u = J(e, "searchTerm", n, {
      // @ts-expect-error ignore the type error here
      defaultValue: "",
      passive: e.searchTerm === void 0
    }), d = J(e, "modelValue", n, {
      // @ts-expect-error ignore the type error here
      defaultValue: e.defaultValue ?? s.value ? [] : void 0,
      passive: e.modelValue === void 0,
      deep: !0
    }), p = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), c = $();
    async function f(L) {
      var z, ee;
      p.value = L, await Y(), L ? (d.value && (Array.isArray(d.value) && s.value ? c.value = (z = x().find((ne) => {
        var Ue, ot;
        return ((ot = (Ue = ne.ref) == null ? void 0 : Ue.dataset) == null ? void 0 : ot.state) === "checked";
      })) == null ? void 0 : z.value : c.value = d.value), (ee = w.value) == null || ee.focus(), j()) : (C.value = !1, k());
    }
    function m(L) {
      if (Array.isArray(d.value) && s.value) {
        const z = d.value.findIndex((ee) => nt(ee, L));
        z === -1 ? d.value.push(L) : d.value.splice(z, 1);
      } else
        d.value = L, f(!1);
    }
    const C = $(!1), w = $(), P = $(), { primitiveElement: _, currentElement: E } = F(), { getItems: x, reactiveItems: B, itemMapSize: I } = Vn("data-radix-vue-combobox-item"), A = vo(() => I.value, () => x().map((L) => L.value)), V = S(() => {
      if (C.value) {
        if (e.filterFunction)
          return e.filterFunction(A.value, u.value);
        if (typeof A.value[0] == "string")
          return A.value.filter((L) => {
            var z;
            return L.toLowerCase().includes((z = u.value) == null ? void 0 : z.toLowerCase());
          });
      }
      return A.value;
    });
    function k() {
      !s.value && d.value ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != "object" ? u.value = d.value.toString() : u.value = "" : u.value = "";
    }
    const N = S(() => V.value.findIndex((L) => nt(L, c.value))), O = S(() => {
      var L;
      return (L = B.value.find((z) => z.value === c.value)) == null ? void 0 : L.ref;
    });
    X(d, async () => {
      await Y(), k();
    }, { immediate: !0 }), X(() => V.value.length, async (L) => {
      await Y(), await Y(), L && N.value === -1 && (c.value = V.value[0]);
    });
    const H = Ne(E);
    function j() {
      O.value instanceof Element && O.value.scrollIntoView({ block: "nearest" });
    }
    return $l({
      searchTerm: u,
      modelValue: d,
      // @ts-expect-error igoring
      onValueChange: m,
      isUserInputted: C,
      multiple: s,
      disabled: l,
      open: p,
      onOpenChange: f,
      filteredOptions: V,
      contentId: te(),
      inputElement: w,
      onInputElementChange: (L) => w.value = L,
      onInputNavigation: async (L) => {
        const z = N.value;
        z === 0 && L === "up" || z === V.value.length - 1 && L === "down" || (z === -1 && V.value.length || L === "home" ? c.value = V.value[0] : L === "end" ? c.value = V.value[V.value.length - 1] : c.value = V.value[L === "up" ? z - 1 : z + 1], j());
      },
      onInputEnter: async () => {
        var L;
        V.value.length && c.value && O.value instanceof Element && ((L = O.value) == null || L.click());
      },
      selectedValue: c,
      onSelectedValueChange: (L) => c.value = L,
      parentElement: E,
      contentElement: P,
      onContentElementChange: (L) => P.value = L
    }), (L, z) => (h(), b(a(He), null, {
      default: v(() => [
        M(a(D), T({
          ref_key: "primitiveElement",
          ref: _,
          style: {
            pointerEvents: a(p) ? "auto" : void 0
          },
          as: L.as,
          "as-child": L.asChild,
          dir: a(r)
        }, L.$attrs), {
          default: v(() => [
            y(L.$slots, "default", {
              activeIndex: N.value,
              open: a(p),
              value: a(d)
            }),
            a(H) && e.name ? (h(), b(a(Rn), {
              key: 0,
              name: e.name,
              value: a(d)
            }, null, 8, ["name", "value"])) : G("", !0)
          ]),
          _: 3
        }, 16, ["style", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), bu = /* @__PURE__ */ g({
  __name: "ComboboxInput",
  props: {
    type: { default: "text" },
    disabled: { type: Boolean },
    autoFocus: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(o) {
    const t = o, e = xe(), { primitiveElement: n, currentElement: s } = F();
    q(() => {
      const d = s.value.nodeName === "INPUT" ? s.value : s.value.querySelector("input");
      d && (e.onInputElementChange(d), setTimeout(() => {
        t.autoFocus && (d == null || d.focus());
      }, 1));
    });
    const l = S(() => t.disabled || e.disabled.value || !1);
    function i(d) {
      e.open.value ? e.onInputNavigation(d.key === "ArrowUp" ? "up" : "down") : e.onOpenChange(!0);
    }
    function r(d) {
      e.open.value && e.onInputNavigation(d.key === "Home" ? "home" : "end");
    }
    function u(d) {
      var p;
      e.searchTerm.value = (p = d.target) == null ? void 0 : p.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;
    }
    return (d, p) => (h(), b(a(D), T({
      ref_key: "primitiveElement",
      ref: n
    }, t, {
      value: a(e).searchTerm.value,
      "aria-expanded": a(e).open.value,
      "aria-controls": a(e).contentId,
      disabled: l.value,
      "aria-disabled": l.value ?? void 0,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "false",
      onInput: u,
      onKeydown: [
        le(oe(i, ["prevent"]), ["down", "up"]),
        le(a(e).onInputEnter, ["enter"]),
        le(oe(r, ["prevent"]), ["home", "end"])
      ]
    }), {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["value", "aria-expanded", "aria-controls", "disabled", "aria-disabled", "onKeydown"]));
  }
}), Cu = /* @__PURE__ */ g({
  __name: "ComboboxAnchor",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    return (t, e) => (h(), b(a(We), { "as-child": "" }, {
      default: v(() => [
        M(a(D), T({
          "as-child": t.asChild,
          as: t.as
        }, t.$attrs), {
          default: v(() => [
            y(t.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ]),
      _: 3
    }));
  }
}), _u = /* @__PURE__ */ g({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = xe(), n = S(() => t.disabled || e.disabled.value || !1);
    return (s, l) => (h(), b(a(D), T({
      type: s.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": a(e).open.value,
      "aria-controls": a(e).contentId,
      "data-state": a(e).open.value ? "open" : "closed",
      disabled: n.value,
      "data-disabled": n.value,
      "aria-disabled": n.value ?? void 0,
      onClick: l[0] || (l[0] = (i) => a(e).onOpenChange(!a(e).open.value))
    }), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]));
  }
}), wu = /* @__PURE__ */ g({
  __name: "ComboboxCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = xe();
    function n() {
      var s;
      e.searchTerm.value = "", (s = e.inputElement.value) == null || s.focus();
    }
    return (s, l) => (h(), b(a(D), T({
      type: s.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      onClick: n
    }), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), [Kn, Pl] = W("ComboboxGroup"), Eu = /* @__PURE__ */ g({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = te(), n = $([]), s = xe(), l = S(() => !s.isUserInputted.value || n.value.length === 0 || s.filteredOptions.value.map((i) => JSON.stringify(i)).some((i) => n.value.map((r) => JSON.stringify(r)).includes(i)));
    return Pl({
      id: e,
      options: n
    }), (i, r) => po((h(), b(a(D), T({ role: "group" }, t, { "aria-labelledby": a(e) }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"])), [
      [gn, l.value]
    ]);
  }
}), xu = /* @__PURE__ */ g({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = Kn({ id: "" });
    return (n, s) => (h(), b(a(D), T(t, {
      id: a(e).id
    }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), [Bl, Sl] = W("ComboboxContent"), Tl = /* @__PURE__ */ g({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean, default: !0 },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { position: s } = U(e), l = xe();
    pt(e.bodyLock);
    const { primitiveElement: i, currentElement: r } = F();
    ft(r);
    const u = S(() => e.position === "popper" ? e : {});
    function d(c) {
      l.onSelectedValueChange("");
    }
    q(() => {
      l.onContentElementChange(r.value);
    });
    const p = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
      "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
      "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
    };
    return Sl({ position: s }), (c, f) => (h(), b(a(Fn), null, {
      default: v(() => [
        c.dismissable ? (h(), b(a(De), {
          key: 0,
          "as-child": "",
          "disable-outside-pointer-events": c.disableOutsidePointerEvents,
          onDismiss: f[0] || (f[0] = (m) => a(l).onOpenChange(!1)),
          onFocusOutside: f[1] || (f[1] = (m) => {
            var C;
            (C = a(l).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n("focusOutside", m);
          }),
          onInteractOutside: f[2] || (f[2] = (m) => n("interactOutside", m)),
          onEscapeKeyDown: f[3] || (f[3] = (m) => n("escapeKeyDown", m)),
          onPointerDownOutside: f[4] || (f[4] = (m) => {
            var C;
            (C = a(l).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n("pointerDownOutside", m);
          })
        }, {
          default: v(() => [
            (h(), b(_e(a(s) === "popper" ? a(Fe) : a(D)), T({ ...c.$attrs, ...u.value }, {
              id: a(l).contentId,
              ref_key: "primitiveElement",
              ref: i,
              role: "listbox",
              "data-state": a(l).open.value ? "open" : "closed",
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none",
                ...a(s) === "popper" ? p : {}
              },
              onPointerleave: d
            }), {
              default: v(() => [
                y(c.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"]))
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])) : (h(), b(_e(a(s) === "popper" ? a(Fe) : a(D)), T({ key: 1 }, { ...c.$attrs, ...u.value }, {
          id: a(l).contentId,
          ref_key: "primitiveElement",
          ref: i,
          role: "listbox",
          "data-state": a(l).open.value ? "open" : "closed",
          style: {
            // flex layout so we can place the scroll buttons properly
            display: "flex",
            flexDirection: "column",
            // reset the outline by default as the content MAY get focused
            outline: "none",
            ...a(s) === "popper" ? p : {}
          },
          onPointerleave: d
        }), {
          default: v(() => [
            y(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "data-state", "style"]))
      ]),
      _: 3
    }));
  }
}), $u = /* @__PURE__ */ g({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    dismissable: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = xe();
    return (i, r) => (h(), b(a(se), {
      present: i.forceMount || a(l).open.value
    }, {
      default: v(() => [
        M(Tl, R(K({ ...a(s), ...i.$attrs })), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Pu = /* @__PURE__ */ g({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = xe(), n = S(() => e.searchTerm.value && e.filteredOptions.value.length === 0);
    return (s, l) => n.value ? (h(), b(a(D), R(T({ key: 0 }, t)), {
      default: v(() => [
        y(s.$slots, "default", {}, () => [
          ue("No options")
        ])
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), Bu = /* @__PURE__ */ g({
  __name: "ComboboxViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), Z(ie, null, [
      M(a(D), T({
        "data-radix-combobox-viewport": "",
        role: "presentation"
      }, { ...e.$attrs, ...t }, { style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      } }), {
        default: v(() => [
          y(e.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      M(a(D), { as: "style" }, {
        default: v(() => [
          ue(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      })
    ], 64));
  }
}), [Dl, Ol] = W("ComboboxItem"), Il = "combobox.select", Su = /* @__PURE__ */ g({
  __name: "ComboboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = U(e), l = xe(), i = Kn({ id: "", options: $([]) }), { primitiveElement: r, currentElement: u } = F(), d = S(
      () => {
        var _, E;
        return l.multiple.value && Array.isArray(l.modelValue.value) ? (_ = l.modelValue.value) == null ? void 0 : _.includes(e.value) : nt((E = l.modelValue) == null ? void 0 : E.value, e.value);
      }
    ), p = S(() => nt(l.selectedValue.value, e.value)), c = $(e.textValue ?? ""), f = te(), m = S(() => l.isUserInputted.value ? l.searchTerm.value === "" || !!l.filteredOptions.value.find((_) => nt(_, e.value)) : !0);
    async function C(_) {
      n("select", _), !(_ != null && _.defaultPrevented) && !s.value && _ && l.onValueChange(e.value);
    }
    function w(_) {
      if (!_)
        return;
      const E = { originalEvent: _, value: e.value };
      fo(Il, C, E);
    }
    async function P(_) {
      await Y(), !_.defaultPrevented && l.onSelectedValueChange(e.value);
    }
    if (e.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return q(() => {
      var _, E, x, B;
      (E = (_ = i.options) == null ? void 0 : _.value) != null && E.includes(e.value) || (x = i.options) == null || x.value.push(e.value), !c.value && ((B = u.value) != null && B.textContent) && (c.value = u.value.textContent);
    }), Ol({
      isSelected: d
    }), (_, E) => (h(), b(a(Ln), null, {
      default: v(() => [
        po(M(a(D), {
          ref_key: "primitiveElement",
          ref: r,
          role: "option",
          tabindex: "-1",
          "aria-labelledby": a(f),
          "data-highlighted": p.value ? "" : void 0,
          "aria-selected": d.value,
          "data-state": d.value ? "checked" : "unchecked",
          "aria-disabled": a(s) || void 0,
          "data-disabled": a(s) ? "" : void 0,
          as: _.as,
          "as-child": _.asChild,
          onClick: w,
          onPointermove: P
        }, {
          default: v(() => [
            y(_.$slots, "default", {}, () => [
              ue(Ke(_.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "as", "as-child"]), [
          [gn, m.value]
        ])
      ]),
      _: 3
    }));
  }
}), Tu = /* @__PURE__ */ g({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Dl();
    return (n, s) => a(e).isSelected.value ? (h(), b(a(D), T({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), Du = /* @__PURE__ */ g({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T({ "aria-hidden": "" }, t), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ou = /* @__PURE__ */ g({
  __name: "ComboboxArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = xe(), n = Bl();
    return (s, l) => a(e).open.value && a(n).position.value === "popper" ? (h(), b(a(Xe), R(T({ key: 0 }, t)), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), Iu = /* @__PURE__ */ g({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Mt = /* @__PURE__ */ g({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(We), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), To = /* @__PURE__ */ g({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Xe), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [je, Nn] = W(["MenuRoot", "MenuSub"], "MenuContext"), [vt, Al] = W("MenuRoot"), Do = /* @__PURE__ */ g({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    onOpenChange: {},
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { modal: s, dir: l } = U(e), i = de(l), r = J(e, "open", n), u = $(), d = $(!1);
    return Q((p) => {
      if (!Ee)
        return;
      const c = () => {
        d.value = !0, document.addEventListener("pointerdown", f, {
          capture: !0,
          once: !0
        }), document.addEventListener("pointermove", f, {
          capture: !0,
          once: !0
        });
      }, f = () => d.value = !1;
      document.addEventListener("keydown", c, { capture: !0 }), p(() => {
        document.removeEventListener("keydown", c, { capture: !0 }), document.removeEventListener("pointerdown", f, {
          capture: !0
        }), document.removeEventListener("pointermove", f, {
          capture: !0
        });
      });
    }), Nn({
      open: r,
      onOpenChange: (p) => {
        r.value = p;
      },
      content: u,
      onContentChange: (p) => {
        u.value = p;
      }
    }), Al({
      onClose: () => {
        r.value = !1;
      },
      isUsingKeyboardRef: d,
      dir: i,
      modal: s
    }), (p, c) => (h(), b(a(He), null, {
      default: v(() => [
        y(p.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Ml = "rovingFocusGroup.onEntryFocus", kl = { bubbles: !1, cancelable: !0 }, Rl = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Vl(o, t) {
  return t !== "rtl" ? o : o === "ArrowLeft" ? "ArrowRight" : o === "ArrowRight" ? "ArrowLeft" : o;
}
function Fl(o, t, e) {
  const n = Vl(o.key, e);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Rl[n];
}
function Hn(o) {
  const t = document.activeElement;
  for (const e of o)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function Ll(o, t) {
  return o.map((e, n) => o[(t + n) % o.length]);
}
const [Kl, Nl] = W("RovingFocusGroup"), Ze = /* @__PURE__ */ g({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(o, { emit: t }) {
    const e = o, n = t, { loop: s, orientation: l, dir: i } = U(e), r = de(i), u = J(e, "currentTabStopId", n, {
      defaultValue: e.defaultCurrentTabStopId,
      passive: e.currentTabStopId === void 0
    }), d = $(!1), p = $(!1), c = $(0), { primitiveElement: f, currentElement: m } = F(), { createCollection: C } = re("rovingFocus"), w = C(m);
    function P(_) {
      const E = !p.value;
      if (_.currentTarget && _.target === _.currentTarget && E && !d.value) {
        const x = new CustomEvent(Ml, kl);
        if (_.currentTarget.dispatchEvent(x), n("entryFocus", x), !x.defaultPrevented) {
          const B = w.value, I = B.find((k) => k.getAttribute("data-active") === "true"), A = B.find(
            (k) => k.id === u.value
          ), V = [I, A, ...B].filter(
            Boolean
          );
          Hn(V);
        }
      }
      p.value = !1;
    }
    return Nl({
      loop: s,
      dir: r,
      orientation: l,
      currentTabStopId: u,
      onItemFocus: (_) => {
        u.value = _;
      },
      onItemShiftTab: () => {
        d.value = !0;
      },
      onFocusableItemAdd: () => {
        c.value++;
      },
      onFocusableItemRemove: () => {
        c.value--;
      }
    }), (_, E) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: f,
      tabindex: d.value || c.value === 0 ? -1 : 0,
      "data-orientation": a(l),
      as: _.as,
      "as-child": _.asChild,
      dir: a(r),
      style: { outline: "none" },
      onMousedown: E[0] || (E[0] = (x) => p.value = !0),
      onFocus: P,
      onBlur: E[1] || (E[1] = (x) => d.value = !1)
    }, {
      default: v(() => [
        y(_.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"]));
  }
}), Qe = /* @__PURE__ */ g({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Kl(), n = te(), s = S(() => t.tabStopId || n), l = S(
      () => e.currentTabStopId.value === s.value
    ), { injectCollection: i } = re("rovingFocus"), r = i();
    q(() => {
      t.focusable && e.onFocusableItemAdd();
    }), fe(() => {
      t.focusable && e.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        e.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget)
        return;
      const p = Fl(
        d,
        e.orientation.value,
        e.dir.value
      );
      if (p !== void 0) {
        d.preventDefault();
        let c = [...r.value];
        if (p === "last")
          c.reverse();
        else if (p === "prev" || p === "next") {
          p === "prev" && c.reverse();
          const f = c.indexOf(
            d.currentTarget
          );
          c = e.loop.value ? Ll(c, f + 1) : c.slice(f + 1);
        }
        Y(() => Hn(c));
      }
    }
    return (d, p) => (h(), b(a(D), {
      "data-radix-vue-collection-item": "",
      tabindex: l.value ? 0 : -1,
      "data-orientation": a(e).orientation.value,
      "data-active": d.active,
      "data-disabled": !d.focusable || void 0,
      as: d.as,
      "as-child": d.asChild,
      onMousedown: p[0] || (p[0] = (c) => {
        d.focusable ? a(e).onItemFocus(s.value) : c.preventDefault();
      }),
      onFocus: p[1] || (p[1] = (c) => a(e).onItemFocus(s.value)),
      onKeydown: u
    }, {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"]));
  }
}), [Oo, Hl] = W("MenuContent"), Io = /* @__PURE__ */ g({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ yn({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...kn
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = je(), l = vt(), { trapFocus: i, disableOutsidePointerEvents: r, loop: u } = U(e);
    bo(), pt(r.value);
    const d = $(""), p = $(0), c = $(0), f = $(null), m = $("right"), C = $(0), w = $(null), { createCollection: P } = re(), { primitiveElement: _, currentElement: E } = F(), x = P(E);
    X(E, (O) => {
      s.onContentChange(O);
    });
    const { handleTypeaheadSearch: B } = Co(x);
    fe(() => {
      window.clearTimeout(p.value);
    });
    function I(O) {
      var j, L;
      return m.value === ((j = f.value) == null ? void 0 : j.side) && Xs(O, (L = f.value) == null ? void 0 : L.area);
    }
    async function A(O) {
      var H;
      n("openAutoFocus", O), !O.defaultPrevented && (O.preventDefault(), (H = E.value) == null || H.focus());
    }
    function V(O) {
      if (O.defaultPrevented)
        return;
      const j = O.target.closest("[data-radix-menu-content]") === O.currentTarget, L = O.ctrlKey || O.altKey || O.metaKey, z = O.key.length === 1, ee = Ye(
        O,
        document.activeElement,
        E.value,
        {
          loop: u.value,
          arrowKeyOptions: "vertical",
          dir: l == null ? void 0 : l.dir.value,
          focus: !0
        }
      );
      if (ee)
        return ee == null ? void 0 : ee.focus();
      if (O.code === "Space" || (j && (O.key === "Tab" && O.preventDefault(), !L && z && B(O.key)), O.target !== E.value) || !Us.includes(O.key))
        return;
      O.preventDefault();
      const ne = x.value;
      Tn.includes(O.key) && ne.reverse(), no(ne);
    }
    function k(O) {
      var H, j;
      (j = (H = O == null ? void 0 : O.currentTarget) == null ? void 0 : H.contains) != null && j.call(H, O.target) || (window.clearTimeout(p.value), d.value = "");
    }
    function N(O) {
      var L;
      if (!st(O))
        return;
      const H = O.target, j = C.value !== O.clientX;
      if ((L = O == null ? void 0 : O.currentTarget) != null && L.contains(H) && j) {
        const z = O.clientX > C.value ? "right" : "left";
        m.value = z, C.value = O.clientX;
      }
    }
    return Hl({
      onItemEnter: (O) => !!I(O),
      onItemLeave: (O) => {
        var H;
        I(O) || ((H = E.value) == null || H.focus(), w.value = null);
      },
      onTriggerLeave: (O) => !!I(O),
      searchRef: d,
      pointerGraceTimerRef: c,
      onPointerGraceIntentChange: (O) => {
        f.value = O;
      }
    }), (O, H) => (h(), b(a(At), {
      "as-child": "",
      trapped: a(i),
      onMountAutoFocus: A,
      onUnmountAutoFocus: H[7] || (H[7] = (j) => n("closeAutoFocus", j))
    }, {
      default: v(() => [
        M(a(De), {
          "as-child": "",
          "disable-outside-pointer-events": a(r),
          onEscapeKeyDown: H[2] || (H[2] = (j) => n("escapeKeyDown", j)),
          onPointerDownOutside: H[3] || (H[3] = (j) => n("pointerDownOutside", j)),
          onFocusOutside: H[4] || (H[4] = (j) => n("focusOutside", j)),
          onInteractOutside: H[5] || (H[5] = (j) => n("interactOutside", j)),
          onDismiss: H[6] || (H[6] = (j) => n("dismiss"))
        }, {
          default: v(() => [
            M(a(Ze), {
              "current-tab-stop-id": w.value,
              "onUpdate:currentTabStopId": H[0] || (H[0] = (j) => w.value = j),
              "as-child": "",
              orientation: "vertical",
              dir: a(l).dir.value,
              loop: a(u),
              onEntryFocus: H[1] || (H[1] = (j) => {
                n("entryFocus", j), a(l).isUsingKeyboardRef.value || j.preventDefault();
              })
            }, {
              default: v(() => [
                M(a(Fe), {
                  ref_key: "primitiveElement",
                  ref: _,
                  role: "menu",
                  as: O.as,
                  "as-child": O.asChild,
                  "aria-orientation": "vertical",
                  "data-radix-menu-content": "",
                  "data-state": a($o)(a(s).open.value),
                  dir: a(l).dir.value,
                  side: O.side,
                  "side-offset": O.sideOffset,
                  align: O.align,
                  "align-offset": O.alignOffset,
                  "avoid-collisions": O.avoidCollisions,
                  "collision-boundary": O.collisionBoundary,
                  "collision-padding": O.collisionPadding,
                  "arrow-padding": O.arrowPadding,
                  sticky: O.sticky,
                  "hide-when-detached": O.hideWhenDetached,
                  onKeydown: V,
                  onBlur: k,
                  onPointermove: N
                }, {
                  default: v(() => [
                    y(O.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "sticky", "hide-when-detached"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Wn = /* @__PURE__ */ g({
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, { primitiveElement: n, currentElement: s } = F(), l = Oo(), i = $(!1);
    async function r(d) {
      if (!d.defaultPrevented && st(d)) {
        if (e.disabled)
          l.onItemLeave(d);
        else if (!l.onItemEnter(d)) {
          const c = d.currentTarget;
          c == null || c.focus();
        }
      }
    }
    async function u(d) {
      await Y(), !d.defaultPrevented && st(d) && l.onItemLeave(d);
    }
    return t({
      el: s
    }), (d, p) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: n,
      role: "menuitem",
      tabindex: "-1",
      as: d.as,
      "as-child": d.asChild,
      "data-radix-vue-collection-item": "",
      "aria-disabled": d.disabled || void 0,
      "data-disabled": d.disabled ? "" : void 0,
      "data-highlighted": i.value ? "" : void 0,
      onPointermove: r,
      onPointerleave: u,
      onFocus: p[0] || (p[0] = async (c) => {
        await Y(), !(c.defaultPrevented || d.disabled) && (i.value = !0);
      }),
      onBlur: p[1] || (p[1] = async (c) => {
        await Y(), !c.defaultPrevented && (i.value = !1);
      })
    }, {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"]));
  }
}), mt = /* @__PURE__ */ g({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: l } = F(), i = vt(), r = Oo(), u = $(!1);
    async function d() {
      const p = l.value;
      if (!e.disabled && p) {
        const c = new CustomEvent(js, {
          bubbles: !0,
          cancelable: !0
        });
        n("select", c), await Y(), c.defaultPrevented ? u.value = !1 : i.onClose();
      }
    }
    return (p, c) => (h(), b(Wn, T(e, {
      ref_key: "primitiveElement",
      ref: s,
      onClick: d,
      onPointerdown: c[0] || (c[0] = () => {
        u.value = !0;
      }),
      onPointerup: c[1] || (c[1] = async (f) => {
        var m;
        await Y(), !f.defaultPrevented && (u.value || (m = f.currentTarget) == null || m.click());
      }),
      onKeydown: c[2] || (c[2] = async (f) => {
        const m = a(r).searchRef.value !== "";
        p.disabled || m && f.key === " " || a(oo).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: v(() => [
        y(p.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Wl, jn] = W(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
), Ao = /* @__PURE__ */ g({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Wl({
      checked: $(!1)
    });
    return (e, n) => (h(), b(a(se), {
      present: e.forceMount || a(Pt)(a(t).checked.value) || a(t).checked.value === !0
    }, {
      default: v(() => [
        M(a(D), {
          as: e.as,
          "as-child": e.asChild,
          "data-state": a(Po)(a(t).checked.value)
        }, {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Mo = /* @__PURE__ */ g({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = J(e, "checked", n);
    return jn({ checked: s }), (l, i) => (h(), b(mt, T({ role: "menuitemcheckbox" }, e, {
      "aria-checked": a(Pt)(a(s)) ? "mixed" : a(s),
      "data-state": a(Po)(a(s)),
      onSelect: i[0] || (i[0] = async (r) => {
        n("select", r), a(Pt)(a(s)) ? s.value = !0 : s.value = !a(s);
      })
    }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), jl = /* @__PURE__ */ g({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = pe(e, n), l = je(), { primitiveElement: i, currentElement: r } = F();
    return ft(r), (u, d) => (h(), b(Io, T({
      ref_key: "primitiveElement",
      ref: i
    }, a(s), {
      "trap-focus": a(l).open.value,
      "disable-outside-pointer-events": a(l).open.value,
      "disable-outside-scroll": !0,
      onDismiss: d[0] || (d[0] = (p) => a(l).onOpenChange(!1)),
      onFocusOutside: d[1] || (d[1] = oe((p) => n("focusOutside", p), ["prevent"]))
    }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), zl = /* @__PURE__ */ g({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = je();
    return (i, r) => (h(), b(Io, T(a(s), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: r[0] || (r[0] = (u) => a(l).onOpenChange(!1))
    }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ko = /* @__PURE__ */ g({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = je(), i = vt();
    return (r, u) => (h(), b(a(se), {
      present: r.forceMount || a(l).open.value
    }, {
      default: v(() => [
        a(i).modal.value ? (h(), b(jl, R(T({ key: 0 }, { ...r.$attrs, ...a(s) })), {
          default: v(() => [
            y(r.$slots, "default")
          ]),
          _: 3
        }, 16)) : (h(), b(zl, R(T({ key: 1 }, { ...r.$attrs, ...a(s) })), {
          default: v(() => [
            y(r.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), kt = /* @__PURE__ */ g({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T({ role: "group" }, t), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ro = /* @__PURE__ */ g({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Vo = /* @__PURE__ */ g({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Ul, ql] = W("MenuRadioGroup"), Fo = /* @__PURE__ */ g({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "modelValue", t);
    return ql({
      modelValue: s,
      onValueChange: (l) => {
        s.value = l;
      }
    }), (l, i) => (h(), b(kt, R(K(e)), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Lo = /* @__PURE__ */ g({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { value: s } = U(e), l = Ul(), i = S(
      () => l.modelValue.value === (s == null ? void 0 : s.value)
    );
    return jn({ checked: i }), (r, u) => (h(), b(mt, T({ role: "menuitemradio" }, e, {
      "aria-checked": i.value,
      "data-state": a(Po)(i.value),
      onSelect: u[0] || (u[0] = async (d) => {
        n("select", d), a(l).onValueChange(a(s));
      })
    }), {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Ko = /* @__PURE__ */ g({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [zn, Gl] = W("MenuSub"), No = /* @__PURE__ */ g({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      defaultValue: !1,
      passive: e.open === void 0
    }), l = je(), i = $(), r = $();
    return Q((u) => {
      (l == null ? void 0 : l.open.value) === !1 && (s.value = !1), u(() => s.value = !1);
    }), Nn({
      open: s,
      onOpenChange: (u) => {
        s.value = u;
      },
      content: r,
      onContentChange: (u) => {
        r.value = u;
      }
    }), Gl({
      triggerId: te(),
      contentId: te(),
      trigger: i,
      onTriggerChange: (u) => {
        i.value = u;
      }
    }), (u, d) => (h(), b(a(He), null, {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Ho = /* @__PURE__ */ g({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = je(), i = vt(), r = zn(), { primitiveElement: u, currentElement: d } = F();
    return (p, c) => (h(), b(a(se), {
      present: p.forceMount || a(l).open.value
    }, {
      default: v(() => [
        M(Io, T(a(s), {
          id: a(r).contentId,
          ref_key: "primitiveElement",
          ref: u,
          "aria-labelledby": a(r).triggerId,
          align: "start",
          side: a(i).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: c[0] || (c[0] = oe((f) => {
            var m;
            a(i).isUsingKeyboardRef.value && ((m = a(d)) == null || m.focus());
          }, ["prevent"])),
          onCloseAutoFocus: c[1] || (c[1] = oe(() => {
          }, ["prevent"])),
          onFocusOutside: c[2] || (c[2] = (f) => {
            f.defaultPrevented || f.target !== a(r).trigger.value && a(l).onOpenChange(!1);
          }),
          onEscapeKeyDown: c[3] || (c[3] = (f) => {
            a(i).onClose(), f.preventDefault();
          }),
          onKeydown: c[4] || (c[4] = (f) => {
            var w, P;
            const m = (w = f.currentTarget) == null ? void 0 : w.contains(f.target), C = a(Gs)[a(i).dir.value].includes(f.key);
            m && C && (a(l).onOpenChange(!1), (P = a(r).trigger.value) == null || P.focus(), f.preventDefault());
          })
        }), {
          default: v(() => [
            y(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Wo = /* @__PURE__ */ g({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = je(), n = vt(), s = zn(), l = Oo(), i = $(null);
    function r() {
      i.value && window.clearTimeout(i.value), i.value = null;
    }
    fe(() => {
      r();
    });
    function u(c) {
      !st(c) || l.onItemEnter(c) || !t.disabled && !e.open.value && !i.value && (l.onPointerGraceIntentChange(null), i.value = window.setTimeout(() => {
        e.onOpenChange(!0), r();
      }, 100));
    }
    async function d(c) {
      var m, C;
      if (!st(c))
        return;
      r();
      const f = (m = e.content.value) == null ? void 0 : m.getBoundingClientRect();
      if (f != null && f.width) {
        const w = (C = e.content.value) == null ? void 0 : C.dataset.side, P = w === "right", _ = P ? -5 : 5, E = f[P ? "left" : "right"], x = f[P ? "right" : "left"];
        l.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: c.clientX + _, y: c.clientY },
            { x: E, y: f.top },
            { x, y: f.top },
            { x, y: f.bottom },
            { x: E, y: f.bottom }
          ],
          side: w
        }), window.clearTimeout(l.pointerGraceTimerRef.value), l.pointerGraceTimerRef.value = window.setTimeout(
          () => l.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (l.onTriggerLeave(c))
          return;
        l.onPointerGraceIntentChange(null);
      }
    }
    async function p(c) {
      var m;
      const f = l.searchRef.value !== "";
      t.disabled || f && c.key === " " || qs[n.dir.value].includes(c.key) && (e.onOpenChange(!0), await Y(), (m = e.content.value) == null || m.focus(), c.preventDefault());
    }
    return (c, f) => (h(), b(Mt, { "as-child": "" }, {
      default: v(() => [
        M(Wn, T(t, {
          id: a(s).triggerId,
          ref: (m) => {
            var C;
            (C = a(s)) == null || C.onTriggerChange(m == null ? void 0 : m.el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": a(e).open.value,
          "aria-controls": a(s).contentId,
          "data-state": a($o)(a(e).open.value),
          onClick: f[0] || (f[0] = async (m) => {
            t.disabled || m.defaultPrevented || (m.currentTarget.focus(), a(e).open.value || a(e).onOpenChange(!0));
          }),
          onPointermove: u,
          onPointerleave: d,
          onKeydown: p
        }), {
          default: v(() => [
            y(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
}), [Un, Yl] = W("ContextMenuRoot"), Au = /* @__PURE__ */ g({
  __name: "ContextMenuRoot",
  props: {
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { dir: s, modal: l } = U(e), i = de(s), r = $(!1);
    return Yl({
      open: r,
      onOpenChange: (u) => {
        r.value = u, n("update:open", u);
      },
      dir: i,
      modal: l
    }), (u, d) => (h(), b(a(Do), {
      open: r.value,
      "onUpdate:open": d[0] || (d[0] = (p) => r.value = p),
      dir: a(i),
      modal: a(l)
    }, {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
});
function ln(o) {
  return o.pointerType !== "mouse";
}
const Mu = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, { disabled: e } = U(t), n = Un(), s = $({ x: 0, y: 0 }), l = S(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: s.value.x,
        right: s.value.x,
        top: s.value.y,
        bottom: s.value.y,
        ...s.value
      })
    })), i = $(0);
    function r() {
      window.clearTimeout(i.value);
    }
    function u(f) {
      s.value = { x: f.clientX, y: f.clientY }, n.onOpenChange(!0);
    }
    async function d(f) {
      e.value || (await Y(), f.defaultPrevented || (r(), u(f), f.preventDefault()));
    }
    async function p(f) {
      e.value || (await Y(), ln(f) && !f.defaultPrevented && (r(), i.value = window.setTimeout(() => u(f), 700)));
    }
    async function c(f) {
      e.value || (await Y(), ln(f) && !f.defaultPrevented && r());
    }
    return (f, m) => (h(), Z(ie, null, [
      M(a(Mt), {
        as: "template",
        element: l.value
      }, null, 8, ["element"]),
      M(a(D), T({
        as: f.as,
        "as-child": f.asChild,
        "data-state": a(n).open.value ? "open" : "closed",
        "data-disabled": a(e) ? "" : void 0,
        style: {
          WebkitTouchCallout: "none"
        }
      }, f.$attrs, {
        onContextmenu: d,
        onPointerdown: p,
        onPointermove: c,
        onPointercancel: c,
        onPointerup: c
      }), {
        default: v(() => [
          y(f.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-state", "data-disabled"])
    ], 64));
  }
}), ku = /* @__PURE__ */ g({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Vo), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ru = /* @__PURE__ */ g({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Un(), l = $(!1);
    return (i, r) => (h(), b(a(ko), T(e, {
      side: "right",
      "side-offset": 2,
      align: "start",
      style: {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: r[0] || (r[0] = (u) => {
        n("closeAutoFocus", u), !u.defaultPrevented && l.value && u.preventDefault(), l.value = !1;
      }),
      onInteractOutside: r[1] || (r[1] = (u) => {
        n("interactOutside", u), !u.defaultPrevented && !a(s).modal.value && (l.value = !0);
      })
    }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Vu = /* @__PURE__ */ g({
  __name: "ContextMenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(To), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Fu = /* @__PURE__ */ g({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(mt), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Lu = /* @__PURE__ */ g({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(kt), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ku = /* @__PURE__ */ g({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ko), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Nu = /* @__PURE__ */ g({
  __name: "ContextMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Mo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hu = /* @__PURE__ */ g({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ao), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Wu = /* @__PURE__ */ g({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ro), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ju = /* @__PURE__ */ g({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Fo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), zu = /* @__PURE__ */ g({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Lo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uu = /* @__PURE__ */ g({
  __name: "ContextMenuSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (l, i) => (h(), b(a(No), {
      open: a(s),
      "onUpdate:open": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), qu = /* @__PURE__ */ g({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t);
    return (l, i) => (h(), b(a(Ho), T(a(s), { style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Gu = /* @__PURE__ */ g({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Wo), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [qn, Xl] = W("DropdownMenuRoot"), Yu = /* @__PURE__ */ g({
  __name: "DropdownMenuRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), l = $(), { modal: i, dir: r } = U(e), u = de(r);
    return Xl({
      open: s,
      onOpenChange: (d) => {
        s.value = d;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      triggerId: te(),
      triggerElement: l,
      contentId: te(),
      modal: i,
      dir: u
    }), (d, p) => (h(), b(a(Do), {
      open: a(s),
      "onUpdate:open": p[0] || (p[0] = (c) => ut(s) ? s.value = c : null),
      dir: a(u),
      modal: a(i)
    }, {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), Xu = /* @__PURE__ */ g({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = qn(), { primitiveElement: n, currentElement: s } = F();
    return q(() => {
      e.triggerElement = s;
    }), (l, i) => (h(), b(a(Mt), { "as-child": "" }, {
      default: v(() => [
        M(a(D), {
          id: a(e).triggerId,
          ref_key: "primitiveElement",
          ref: n,
          type: l.as === "button" ? "button" : void 0,
          "as-child": t.asChild,
          as: l.as,
          "aria-haspopup": "menu",
          "aria-expanded": a(e).open.value,
          "aria-controls": a(e).open.value ? a(e).contentId : void 0,
          "data-disabled": l.disabled ? "" : void 0,
          disabled: l.disabled,
          "data-state": a(e).open.value ? "open" : "closed",
          onClick: i[0] || (i[0] = async (r) => {
            var u;
            !l.disabled && r.button === 0 && r.ctrlKey === !1 && ((u = a(e)) == null || u.onOpenToggle(), await Y(), a(e).open.value && r.preventDefault());
          }),
          onKeydown: i[1] || (i[1] = le(
            (r) => {
              l.disabled || (["Enter", " "].includes(r.key) && a(e).onOpenToggle(), r.key === "ArrowDown" && a(e).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(r.key) && r.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: v(() => [
            y(l.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), Ju = /* @__PURE__ */ g({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Vo), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zu = /* @__PURE__ */ g({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = pe(e, n), l = qn(), i = $(!1);
    function r(u) {
      n("closeAutoFocus", u), !u.defaultPrevented && (i.value || setTimeout(() => {
        var d;
        (d = l.triggerElement.value) == null || d.focus();
      }, 0), i.value = !1, u.preventDefault());
    }
    return (u, d) => {
      var p;
      return h(), b(a(ko), T(a(s), {
        id: a(l).contentId,
        "aria-labelledby": (p = a(l)) == null ? void 0 : p.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: r,
        onInteractOutside: d[0] || (d[0] = (c) => {
          var w;
          if (n("interactOutside", c), c.defaultPrevented)
            return;
          const f = c.detail.originalEvent, m = f.button === 0 && f.ctrlKey === !0, C = f.button === 2 || m;
          (!a(l).modal.value || C) && (i.value = !0), (w = a(l).triggerElement.value) != null && w.contains(c.target) && c.preventDefault();
        })
      }), {
        default: v(() => [
          y(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style"]);
    };
  }
}), Qu = /* @__PURE__ */ g({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(To), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ed = /* @__PURE__ */ g({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(mt), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), td = /* @__PURE__ */ g({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(kt), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), od = /* @__PURE__ */ g({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ko), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nd = /* @__PURE__ */ g({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Mo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ad = /* @__PURE__ */ g({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ao), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sd = /* @__PURE__ */ g({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ro), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ld = /* @__PURE__ */ g({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Fo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), id = /* @__PURE__ */ g({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    return (s, l) => (h(), b(a(Lo), R(K({ ...e, ...n })), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rd = /* @__PURE__ */ g({
  __name: "DropdownMenuSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      passive: e.open === void 0,
      defaultValue: e.defaultOpen ?? !1
    });
    return (l, i) => (h(), b(a(No), {
      open: a(s),
      "onUpdate:open": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), ud = /* @__PURE__ */ g({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t);
    return (l, i) => (h(), b(a(Ho), T(a(s), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), dd = /* @__PURE__ */ g({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Wo), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [jo, Jl] = W("HoverCardRoot"), cd = /* @__PURE__ */ g({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { openDelay: s, closeDelay: l } = U(e), i = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), r = $(0), u = $(0), d = $(!1), p = $(!1);
    function c() {
      clearTimeout(u.value), r.value = window.setTimeout(() => i.value = !0, s.value);
    }
    function f() {
      clearTimeout(r.value), !d.value && !p.value && (u.value = window.setTimeout(() => i.value = !1, l.value));
    }
    function m() {
      i.value = !1;
    }
    return Jl({
      open: i,
      onOpenChange(C) {
        i.value = C;
      },
      onOpen: c,
      onClose: f,
      onDismiss: m,
      hasSelectionRef: d,
      isPointerDownOnContentRef: p
    }), (C, w) => (h(), b(a(He), null, {
      default: v(() => [
        y(C.$slots, "default")
      ]),
      _: 3
    }));
  }
});
function Bt(o) {
  return (t) => t.pointerType === "touch" ? void 0 : o();
}
function Zl(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
const pd = /* @__PURE__ */ g({
  __name: "HoverCardTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(o) {
    const t = jo();
    return (e, n) => (h(), b(a(We), { "as-child": "" }, {
      default: v(() => [
        M(a(D), {
          "as-child": e.asChild,
          as: e.as,
          "data-state": a(t).open.value ? "open" : "closed",
          onPointerenter: n[0] || (n[0] = (s) => a(Bt)(a(t).onOpen)(s)),
          onPointerleave: n[1] || (n[1] = (s) => a(Bt)(a(t).onClose)(s)),
          onFocus: n[2] || (n[2] = (s) => a(t).onOpen()),
          onBlur: a(t).onClose,
          onTouchstart: oe(() => {
          }, ["prevent"])
        }, {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "data-state", "onBlur"])
      ]),
      _: 3
    }));
  }
}), fd = /* @__PURE__ */ g({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ql = /* @__PURE__ */ g({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Ot(e), { primitiveElement: l, currentElement: i } = F(), r = jo(), u = $(!1);
    let d;
    Q((c) => {
      if (u.value) {
        const f = document.body;
        d = f.style.userSelect || f.style.webkitUserSelect, f.style.userSelect = "none", f.style.webkitUserSelect = "none", c(() => {
          f.style.userSelect = d, f.style.webkitUserSelect = d;
        });
      }
    });
    function p() {
      u.value = !1, r.isPointerDownOnContentRef.value = !1, Y(() => {
        var f;
        ((f = document.getSelection()) == null ? void 0 : f.toString()) !== "" && (r.hasSelectionRef.value = !0);
      });
    }
    return q(() => {
      i.value && (document.addEventListener("pointerup", p), Zl(i.value).forEach((f) => f.setAttribute("tabindex", "-1")));
    }), fe(() => {
      document.removeEventListener("pointerup", p), r.hasSelectionRef.value = !1, r.isPointerDownOnContentRef.value = !1;
    }), (c, f) => (h(), b(a(De), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: f[1] || (f[1] = (m) => n("escapeKeyDown", m)),
      onPointerDownOutside: f[2] || (f[2] = (m) => n("pointerDownOutside", m)),
      onFocusOutside: f[3] || (f[3] = oe((m) => n("focusOutside", m), ["prevent"])),
      onDismiss: a(r).onDismiss
    }, {
      default: v(() => [
        M(a(Fe), T({
          ref_key: "primitiveElement",
          ref: l
        }, { ...a(s), ...c.$attrs }, {
          "data-state": a(r).open.value ? "open" : "closed",
          style: {
            userSelect: u.value ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: u.value ? "text" : void 0,
            // re-namespace exposed content custom properties
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          },
          onPointerdown: f[0] || (f[0] = (m) => {
            m.currentTarget.contains(m.target) && (u.value = !0), a(r).hasSelectionRef.value = !1, a(r).isPointerDownOnContentRef.value = !0;
          })
        }), {
          default: v(() => [
            y(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }, 8, ["onDismiss"]));
  }
}), vd = /* @__PURE__ */ g({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = jo();
    return (i, r) => (h(), b(a(se), {
      present: i.forceMount || a(l).open.value
    }, {
      default: v(() => [
        M(Ql, T(a(s), {
          onPointerenter: r[0] || (r[0] = (u) => a(Bt)(a(l).onOpen)(u)),
          onPointerleave: r[1] || (r[1] = (u) => a(Bt)(a(l).onClose)(u))
        }), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), md = /* @__PURE__ */ g({
  __name: "HoverCardArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Xe), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hd = /* @__PURE__ */ g({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T(t, {
      onMousedown: n[0] || (n[0] = (s) => {
        !s.defaultPrevented && s.detail > 1 && s.preventDefault();
      })
    }), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Rt, ei] = W("MenubarRoot"), yd = /* @__PURE__ */ g({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: l } = F(), { createCollection: i } = re("menubar");
    i(l);
    const r = J(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), u = $(null), { dir: d, loop: p } = U(e), c = de(d);
    return ei({
      modelValue: r,
      dir: c,
      loop: p,
      onMenuOpen: (f) => {
        r.value = f, u.value = f;
      },
      onMenuClose: () => {
        r.value = "";
      },
      onMenuToggle: (f) => {
        r.value = r.value ? "" : f, u.value = f;
      }
    }), (f, m) => (h(), b(a(Ze), {
      "current-tab-stop-id": u.value,
      "onUpdate:currentTabStopId": m[0] || (m[0] = (C) => u.value = C),
      orientation: "horizontal",
      loop: a(p),
      dir: a(c),
      "as-child": ""
    }, {
      default: v(() => [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: s,
          role: "menubar"
        }, {
          default: v(() => [
            y(f.$slots, "default")
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["current-tab-stop-id", "loop", "dir"]));
  }
}), [zo, ti] = W("MenubarMenu"), gd = /* @__PURE__ */ g({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(o) {
    const e = o.value ?? te(), n = Rt(), s = $(), l = $(!1), i = S(() => n.modelValue.value === e);
    return X(i, () => {
      i.value || (l.value = !1);
    }), ti({
      value: e,
      triggerElement: s,
      triggerId: e,
      contentId: te(),
      wasKeyboardTriggerOpenRef: l
    }), (r, u) => (h(), b(a(Do), {
      open: i.value,
      modal: !1,
      dir: a(n).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || a(n).onMenuClose();
      })
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir"]));
  }
}), bd = /* @__PURE__ */ g({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = Rt(), e = zo(), { primitiveElement: n, currentElement: s } = F(), l = $(!1), i = S(() => t.modelValue.value === e.value);
    return q(() => {
      e.triggerElement = s;
    }), (r, u) => (h(), b(a(Qe), {
      "as-child": "",
      focusable: !r.disabled,
      "tab-stop-id": a(e).value
    }, {
      default: v(() => [
        M(a(Mt), { "as-child": "" }, {
          default: v(() => [
            M(a(D), {
              id: a(e).triggerId,
              ref_key: "primitiveElement",
              ref: n,
              as: r.as,
              type: r.as === "button" ? "button" : void 0,
              role: "menuitem",
              "aria-haspopup": "menu",
              "aria-expanded": i.value,
              "aria-controls": i.value ? a(e).contentId : void 0,
              "data-highlighted": l.value ? "" : void 0,
              "data-state": i.value ? "open" : "closed",
              "data-disabled": r.disabled ? "" : void 0,
              disabled: r.disabled,
              "data-value": a(e).value,
              "data-radix-vue-collection-item": "",
              onPointerdown: u[0] || (u[0] = (d) => {
                !r.disabled && d.button === 0 && d.ctrlKey === !1 && (a(t).onMenuOpen(a(e).value), i.value || d.preventDefault());
              }),
              onPointerenter: u[1] || (u[1] = () => {
                var p;
                !!a(t).modelValue.value && !i.value && (a(t).onMenuOpen(a(e).value), (p = a(s)) == null || p.focus());
              }),
              onKeydown: u[2] || (u[2] = le((d) => {
                r.disabled || (["Enter", " "].includes(d.key) && a(t).onMenuToggle(a(e).value), d.key === "ArrowDown" && a(t).onMenuOpen(a(e).value), ["Enter", " ", "ArrowDown"].includes(d.key) && (a(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));
              }, ["enter", "space", "arrow-down"])),
              onFocus: u[3] || (u[3] = (d) => l.value = !0),
              onBlur: u[4] || (u[4] = (d) => l.value = !1)
            }, {
              default: v(() => [
                y(r.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
}), Cd = /* @__PURE__ */ g({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Vo), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _d = /* @__PURE__ */ g({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = Rt(), i = zo(), { injectCollection: r } = re("menubar"), u = r(), d = $(!1);
    function p(c) {
      const m = c.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ), w = (l.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === c.key;
      if (!w && m)
        return;
      let _ = u.value.map((B) => B.dataset.value);
      w && _.reverse();
      const E = _.indexOf(i.value);
      _ = l.loop.value ? _o(_, E + 1) : _.slice(E + 1);
      const [x] = _;
      x && l.onMenuOpen(x);
    }
    return (c, f) => (h(), b(a(ko), T({
      id: a(i).contentId,
      "aria-labelledby": a(i).triggerId,
      "data-radix-menubar-content": ""
    }, a(s), {
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (m) => {
        var w;
        !!!a(l).modelValue.value && !d.value && ((w = a(i).triggerElement.value) == null || w.focus()), d.value = !1, m.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (m) => {
        const C = m.target;
        a(u).some((P) => P.contains(C)) && m.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (m) => {
        d.value = !0;
      }),
      onEntryFocus: f[3] || (f[3] = (m) => {
        a(i).wasKeyboardTriggerOpenRef.value || m.preventDefault();
      }),
      onKeydown: le(p, ["arrow-right", "arrow-left"])
    }), {
      default: v(() => [
        y(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "style"]));
  }
}), wd = /* @__PURE__ */ g({
  __name: "MenubarArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(To), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ed = /* @__PURE__ */ g({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(mt), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), xd = /* @__PURE__ */ g({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(kt), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), $d = /* @__PURE__ */ g({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ko), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Pd = /* @__PURE__ */ g({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Mo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Bd = /* @__PURE__ */ g({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ao), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Sd = /* @__PURE__ */ g({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Ro), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Td = /* @__PURE__ */ g({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = ce(t);
    return (l, i) => (h(), b(a(Fo), R(K({ ...e, ...a(s) })), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dd = /* @__PURE__ */ g({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    return (s, l) => (h(), b(a(Lo), R(K({ ...e, ...n })), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Od = /* @__PURE__ */ g({
  __name: "MenubarSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "open", t, {
      defaultValue: e.defaultOpen ?? !1,
      passive: e.open === void 0
    });
    return (l, i) => (h(), b(a(No), {
      open: a(s),
      "onUpdate:open": i[0] || (i[0] = (r) => ut(s) ? s.value = r : null)
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Id = /* @__PURE__ */ g({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = pe(o, t), { injectCollection: l } = re("menubar"), i = Rt(), r = zo(), u = l();
    function d(p) {
      if (p.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ))
        return;
      let m = u.value.map((P) => P.dataset.value);
      const C = m.indexOf(r.value);
      m = i.loop.value ? _o(m, C + 1) : m.slice(C + 1);
      const [w] = m;
      w && i.onMenuOpen(w);
    }
    return (p, c) => (h(), b(a(Ho), T(a(s), {
      "data-radix-menubar-content": "",
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onKeydown: le(d, ["arrow-right"])
    }), {
      default: v(() => [
        y(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Ad = /* @__PURE__ */ g({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Wo), T({ "data-radix-menubar-subtrigger": "" }, t), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Oe, Gn] = W(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext"), Md = /* @__PURE__ */ g({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: { default: void 0 },
    defaultValue: {},
    dir: {},
    orientation: { default: "horizontal" },
    delayDuration: { default: 200 },
    skipDelayDuration: { default: 300 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), l = $(""), { primitiveElement: i, currentElement: r } = F(), u = $(), d = $(), { createCollection: p } = re("nav");
    p(u);
    const { delayDuration: c, skipDelayDuration: f, dir: m } = U(e), C = de(m), w = mo(!1, f), P = S(() => s.value !== "" || w.value ? 150 : c.value), _ = ho((E) => {
      l.value = s.value, s.value = E;
    }, P);
    return Gn({
      isRootMenu: !0,
      modelValue: s,
      previousValue: l,
      baseId: te(),
      dir: C,
      orientation: e.orientation,
      rootNavigationMenu: r,
      indicatorTrack: u,
      onIndicatorTrackChange: (E) => {
        u.value = E;
      },
      viewport: d,
      onViewportChange: (E) => {
        d.value = E;
      },
      onTriggerEnter: (E) => {
        _(E);
      },
      onTriggerLeave: () => {
        w.value = !0, _("");
      },
      onContentEnter: (E) => {
        _(E);
      },
      onContentLeave: () => {
        _("");
      },
      onItemSelect: (E) => {
        l.value = s.value, s.value = E;
      },
      onItemDismiss: () => {
        l.value = s.value, s.value = "";
      }
    }), (E, x) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: i,
      "aria-label": "Main",
      as: E.as,
      "as-child": E.asChild,
      "data-orientation": E.orientation,
      dir: a(C)
    }, {
      default: v(() => [
        y(E.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "dir"]));
  }
});
function Vt(o) {
  return o ? "open" : "closed";
}
function Yn(o, t) {
  return `${o}-trigger-${t}`;
}
function Uo(o, t) {
  return `${o}-content-${t}`;
}
const $t = "navigationMenu.rootContentDismiss";
function so(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const s = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function Xn(o) {
  const t = document.activeElement;
  return o.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));
}
function oi(o) {
  return o.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    o.forEach((t) => {
      const e = t.dataset.tabindex;
      t.setAttribute("tabindex", e);
    });
  };
}
const [qo, ni] = W("NavigationMenuItem"), kd = /* @__PURE__ */ g({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  setup(o) {
    const t = o, { injectCollection: e } = re("nav"), n = e(), s = Oe(), l = t.value || te(), i = $(), r = $(), u = Uo(s.baseId, l);
    let d = () => ({});
    const p = $(!1);
    async function c(w = "start") {
      const P = document.getElementById(u);
      if (P) {
        d();
        const _ = so(P);
        _.length && Xn(w === "start" ? _ : _.reverse());
      }
    }
    function f() {
      const w = document.getElementById(u);
      if (w) {
        const P = so(w);
        P.length && (d = oi(P));
      }
    }
    ni({
      value: l,
      contentId: u,
      triggerRef: i,
      focusProxyRef: r,
      wasEscapeCloseRef: p,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function m() {
      var w;
      s.onItemDismiss(), (w = i.value) == null || w.focus();
    }
    function C(w) {
      const P = document.activeElement;
      if (w.keyCode === 32 || w.key === "Enter")
        if (s.modelValue.value === l) {
          m(), w.preventDefault();
          return;
        } else {
          w.target.click(), w.preventDefault();
          return;
        }
      const _ = n.value.filter(
        (x) => {
          var B;
          return (B = x.parentElement) == null ? void 0 : B.hasAttribute("data-menu-item");
        }
      ), E = Ye(w, P, void 0, {
        itemsArray: _,
        loop: !1
      });
      E && (E == null || E.focus()), w.preventDefault(), w.stopPropagation();
    }
    return (w, P) => (h(), b(a(D), {
      "as-child": t.asChild,
      as: w.as,
      "data-menu-item": "",
      onKeydown: le(C, ["up", "down", "left", "right", "home", "end", "space"])
    }, {
      default: v(() => [
        y(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), ai = /* @__PURE__ */ g({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { injectCollection: s } = re("nav"), l = s(), { primitiveElement: i, currentElement: r } = F(), u = Oe(), d = qo(), p = Yn(u.baseId, d.value), c = Uo(u.baseId, d.value), f = $(null), m = S(() => {
      const B = l.value.map((O) => O.id.split("trigger-")[1]);
      u.dir.value === "rtl" && B.reverse();
      const I = B.indexOf(u.modelValue.value), A = B.indexOf(u.previousValue.value), V = d.value === u.modelValue.value, k = A === B.indexOf(d.value);
      if (!V && !k)
        return f.value;
      const N = (() => {
        if (I !== A) {
          if (V && A !== -1)
            return I > A ? "from-end" : "from-start";
          if (k && I !== -1)
            return I > A ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = N, N;
    });
    function C(x) {
      var B, I;
      if (n("focusOutside", x), n("interactOutside", x), !x.defaultPrevented) {
        d.onContentFocusOutside();
        const A = x.target;
        (I = (B = u.rootNavigationMenu) == null ? void 0 : B.value) != null && I.contains(A) && x.preventDefault();
      }
    }
    function w(x) {
      var B;
      if (n("pointerDownOutside", x), !x.defaultPrevented) {
        const I = x.target, A = l.value.some(
          (k) => k.contains(I)
        ), V = u.isRootMenu && ((B = u.viewport.value) == null ? void 0 : B.contains(I));
        (A || V || !u.isRootMenu) && x.preventDefault();
      }
    }
    Q((x) => {
      const B = r.value;
      if (u.isRootMenu && B) {
        const I = () => {
          var A;
          d.onRootContentClose(), B.contains(document.activeElement) && ((A = d.triggerRef.value) == null || A.focus());
        };
        B.addEventListener($t, I), x(
          () => B.removeEventListener($t, I)
        );
      }
    });
    function P(x) {
      var B, I;
      n("escapeKeyDown", x), x.defaultPrevented || (u.onItemDismiss(), (I = (B = d.triggerRef) == null ? void 0 : B.value) == null || I.focus(), d.wasEscapeCloseRef.value = !0);
    }
    function _(x) {
      var k;
      const B = x.altKey || x.ctrlKey || x.metaKey, I = x.key === "Tab" && !B, A = so(x.currentTarget);
      if (I) {
        const N = document.activeElement, O = A.findIndex(
          (L) => L === N
        ), j = x.shiftKey ? A.slice(0, O).reverse() : A.slice(O + 1, A.length);
        if (Xn(j))
          x.preventDefault();
        else {
          (k = d.focusProxyRef.value) == null || k.focus();
          return;
        }
      }
      const V = Ye(
        x,
        document.activeElement,
        void 0,
        { itemsArray: A, loop: !1 }
      );
      V == null || V.focus(), !(x.key === "Enter" || x.key === "Escape") && (x.preventDefault(), x.stopPropagation());
    }
    function E() {
      var B;
      const x = new Event($t, {
        bubbles: !0,
        cancelable: !0
      });
      (B = r.value) == null || B.dispatchEvent(x);
    }
    return (x, B) => (h(), b(a(De), T({
      id: a(c),
      ref_key: "primitiveElement",
      ref: i,
      "aria-labelledby": a(p),
      "data-motion": m.value,
      "data-state": a(Vt)(a(u).modelValue.value === a(d).value),
      "data-orientation": a(u).orientation
    }, e, {
      onKeydown: _,
      onEscapeKeyDown: P,
      onPointerDownOutside: w,
      onFocusOutside: C,
      onDismiss: E
    }), {
      default: v(() => [
        y(x.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]));
  }
}), Rd = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ce(n), l = Tt(), i = Oe(), r = qo(), u = S(() => r.value === i.modelValue.value), d = S(() => !i.modelValue.value && i.previousValue.value ? i.previousValue.value === r.value : !1);
    function p(c) {
      n("pointerDownOutside", c), c.preventDefault || i.onContentLeave();
    }
    return (c, f) => a(l) ? (h(), b(Ge, {
      key: 0,
      to: a(i).viewport.value,
      disabled: !a(i).viewport.value
    }, [
      M(a(se), {
        present: c.forceMount || u.value || d.value
      }, {
        default: v(() => [
          M(ai, T({
            "data-state": a(Vt)(u.value),
            style: {
              pointerEvents: !u.value && a(i).isRootMenu ? "none" : void 0
            }
          }, { ...c.$attrs, ...e, ...a(s) }, {
            onPointerenter: f[0] || (f[0] = (m) => a(i).onContentEnter(a(r).value)),
            onPointerleave: f[1] || (f[1] = (m) => a(i).onContentLeave()),
            onPointerdown: p,
            onFocusOutside: f[2] || (f[2] = (m) => n("focusOutside", m)),
            onInteractOutside: f[3] || (f[3] = (m) => n("interactOutside", m))
          }), {
            default: v(() => [
              y(c.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["present"])
    ], 8, ["to", "disabled"])) : G("", !0);
  }
}), Vd = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { injectCollection: e } = re("nav"), n = e(), s = Oe(), l = $(), i = S(() => s.orientation === "horizontal"), r = S(() => !!s.modelValue.value), u = $();
    function d() {
      u.value && (l.value = {
        size: i.value ? u.value.offsetWidth : u.value.offsetHeight,
        offset: i.value ? u.value.offsetLeft : u.value.offsetTop
      });
    }
    return Q(() => {
      if (!s.modelValue.value) {
        l.value = void 0;
        return;
      }
      const p = n.value;
      u.value = p.find(
        (c) => c.id.includes(s.modelValue.value)
      ), d();
    }), we(u, d), we(s.indicatorTrack, d), (p, c) => a(s).indicatorTrack.value ? (h(), b(Ge, {
      key: 0,
      to: a(s).indicatorTrack.value
    }, [
      M(a(se), {
        present: p.forceMount || r.value
      }, {
        default: v(() => {
          var f, m, C, w;
          return [
            M(a(D), T({
              "aria-hidden": "",
              "data-state": r.value ? "visible" : "hidden",
              "data-orientation": a(s).orientation,
              "as-child": t.asChild,
              as: p.as,
              style: {
                position: "absolute",
                ...i.value ? {
                  left: 0,
                  width: `${(f = l.value) == null ? void 0 : f.size}px`,
                  transform: `translateX(${(m = l.value) == null ? void 0 : m.offset}px)`
                } : {
                  top: 0,
                  height: `${(C = l.value) == null ? void 0 : C.size}px`,
                  transform: `translateY(${(w = l.value) == null ? void 0 : w.offset}px)`
                }
              }
            }, p.$attrs), {
              default: v(() => [
                y(p.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "data-orientation", "as-child", "as", "style"])
          ];
        }),
        _: 3
      }, 8, ["present"])
    ], 8, ["to"])) : G("", !0);
  }
}), Fd = /* @__PURE__ */ g({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    async function s(l) {
      var i;
      if (n("select", l), await Y(), !l.defaultPrevented && !l.metaKey) {
        const r = new CustomEvent(
          $t,
          {
            bubbles: !0,
            cancelable: !0
          }
        );
        (i = l.target) == null || i.dispatchEvent(r);
      }
    }
    return (l, i) => (h(), b(a(D), {
      as: l.as,
      "data-active": l.active ? "" : void 0,
      "aria-current": l.active ? "page" : void 0,
      "as-child": e.asChild,
      "data-radix-vue-collection-item": "",
      onClick: s
    }, {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "data-active", "aria-current", "as-child"]));
  }
}), Ld = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  setup(o) {
    const t = o, e = Oe(), { primitiveElement: n, currentElement: s } = F();
    return q(() => {
      e.onIndicatorTrackChange(s.value);
    }), (l, i) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: n,
      style: { position: "relative" }
    }, {
      default: v(() => [
        M(a(D), T(l.$attrs, {
          "as-child": t.asChild,
          as: l.as,
          "data-orientation": a(e).orientation
        }), {
          default: v(() => [
            y(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-orientation"])
      ]),
      _: 3
    }, 512));
  }
}), Kd = /* @__PURE__ */ g({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {},
    defaultValue: {},
    orientation: { default: "horizontal" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), l = $(""), i = Oe(), { primitiveElement: r, currentElement: u } = F(), d = $(), p = $(), { createCollection: c } = re("nav");
    return c(d), Gn({
      ...i,
      isRootMenu: !1,
      modelValue: s,
      previousValue: l,
      orientation: e.orientation,
      rootNavigationMenu: u,
      indicatorTrack: d,
      onIndicatorTrackChange: (f) => {
        d.value = f;
      },
      viewport: p,
      onViewportChange: (f) => {
        p.value = f;
      },
      onTriggerEnter: (f) => {
        s.value = f;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (f) => {
        s.value = f;
      },
      onItemDismiss: () => {
        s.value = "";
      }
    }), (f, m) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: r,
      "data-orientation": f.orientation,
      "as-child": e.asChild,
      as: f.as
    }, {
      default: v(() => [
        y(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as-child", "as"]));
  }
}), si = ["aria-owns"], Nd = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Oe(), n = qo(), { primitiveElement: s, currentElement: l } = F(), i = $(""), r = $(""), u = mo(!1, 300), d = $(!1), p = S(() => n.value === e.modelValue.value);
    q(() => {
      n.triggerRef = l, i.value = Yn(e.baseId, n.value), r.value = Uo(e.baseId, n.value);
    });
    function c() {
      d.value = !1, n.wasEscapeCloseRef.value = !1;
    }
    function f(E) {
      if (E.pointerType === "mouse") {
        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)
          return;
        e.onTriggerEnter(n.value), u.value = !0;
      }
    }
    function m(E) {
      if (E.pointerType === "mouse") {
        if (t.disabled)
          return;
        e.onTriggerLeave(), u.value = !1;
      }
    }
    function C() {
      u.value || (p.value ? e.onItemSelect("") : e.onItemSelect(n.value), d.value = p.value);
    }
    function w(E) {
      const B = { horizontal: "ArrowDown", vertical: e.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight" }[e.orientation];
      p.value && E.key === B && (n.onEntryKeyDown(), E.preventDefault(), E.stopPropagation());
    }
    function P(E) {
      n.focusProxyRef.value = ve(E);
    }
    function _(E) {
      const x = document.getElementById(n.contentId), B = E.relatedTarget, I = B === l.value, A = x == null ? void 0 : x.contains(B);
      (I || !A) && n.onFocusProxyEnter(I ? "start" : "end");
    }
    return (E, x) => (h(), Z(ie, null, [
      M(a(D), T({
        id: i.value,
        ref_key: "primitiveElement",
        ref: s,
        disabled: E.disabled,
        "data-disabled": E.disabled ? "" : void 0,
        "data-state": a(Vt)(p.value),
        "aria-expanded": p.value,
        "aria-controls": r.value,
        "as-child": t.asChild,
        as: E.as
      }, E.$attrs, {
        "data-radix-vue-collection-item": "",
        onPointerenter: c,
        onPointermove: f,
        onPointerleave: m,
        onClick: C,
        onKeydown: w
      }), {
        default: v(() => [
          y(E.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"]),
      p.value ? (h(), Z(ie, { key: 0 }, [
        M(a(Je), {
          ref: P,
          "aria-hidden": "",
          tabindex: 0,
          onFocus: _
        }),
        a(e).viewport ? (h(), Z("span", {
          key: 0,
          "aria-owns": r.value
        }, null, 8, si)) : G("", !0)
      ], 64)) : G("", !0)
    ], 64));
  }
}), Hd = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const { primitiveElement: t, currentElement: e } = F(), n = Oe(), s = $(), l = S(() => !!n.modelValue.value), i = S(() => n.modelValue.value);
    X(e, () => {
      e.value && n.onViewportChange(e.value);
    });
    const r = $();
    return X([i, l], async () => {
      var d, p;
      if (await Y(), !e.value)
        return;
      const u = (p = (d = e.value.querySelector("[data-state=open]")) == null ? void 0 : d.children) == null ? void 0 : p[0];
      r.value = u;
    }, { immediate: !0 }), we(r, () => {
      r.value && (s.value = {
        width: r.value.offsetWidth,
        height: r.value.offsetHeight
      });
    }), (u, d) => (h(), b(a(se), {
      present: u.forceMount || l.value
    }, {
      default: v(() => {
        var p, c;
        return [
          M(a(D), T(u.$attrs, {
            ref_key: "primitiveElement",
            ref: t,
            as: u.as,
            "as-child": u.asChild,
            "data-state": a(Vt)(l.value),
            "data-orientation": a(n).orientation,
            style: {
              // Prevent interaction when animating out
              pointerEvents: !l.value && a(n).isRootMenu ? "none" : void 0,
              "--radix-navigation-menu-viewport-width": s.value ? `${(p = s.value) == null ? void 0 : p.width}px` : void 0,
              "--radix-navigation-menu-viewport-height": s.value ? `${(c = s.value) == null ? void 0 : c.height}px` : void 0
            },
            onPointerenter: d[0] || (d[0] = (f) => a(n).onContentEnter(a(n).modelValue.value)),
            onPointerleave: d[1] || (d[1] = (f) => a(n).onContentLeave())
          }), {
            default: v(() => [
              y(u.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state", "data-orientation", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), [et, li] = W("PaginationRoot"), Wd = /* @__PURE__ */ g({
  __name: "PaginationRoot",
  props: {
    page: {},
    defaultPage: { default: 1 },
    itemsPerPage: { default: 10 },
    total: { default: 0 },
    siblingCount: { default: 2 },
    disabled: { type: Boolean },
    showEdges: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:page"],
  setup(o, { emit: t }) {
    const e = o, n = t, { siblingCount: s, disabled: l, showEdges: i } = U(e), r = J(e, "page", n, {
      defaultValue: e.defaultPage,
      passive: e.page === void 0
    }), u = S(() => Math.ceil(e.total / e.itemsPerPage));
    return li({
      page: r,
      onPageChange(d) {
        r.value = d;
      },
      pageCount: u,
      siblingCount: s,
      disabled: l,
      showEdges: i
    }), (d, p) => (h(), b(a(D), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: v(() => [
        y(d.$slots, "default", { page: a(r) })
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), jd = /* @__PURE__ */ g({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T({ "data-type": "ellipsis" }, t), {
      default: v(() => [
        y(e.$slots, "default", {}, () => [
          ue("")
        ])
      ]),
      _: 3
    }, 16));
  }
}), zd = /* @__PURE__ */ g({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = et();
    return (n, s) => (h(), b(a(D), T(t, {
      "aria-label": "First Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: a(e).page.value === 1 || a(e).disabled.value,
      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(1))
    }), {
      default: v(() => [
        y(n.$slots, "default", {}, () => [
          ue("First page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), Ud = /* @__PURE__ */ g({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = et();
    return (n, s) => (h(), b(a(D), T(t, {
      "aria-label": "Last Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: a(e).page.value === a(e).pageCount.value || a(e).disabled.value,
      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(a(e).pageCount.value))
    }), {
      default: v(() => [
        y(n.$slots, "default", {}, () => [
          ue("Last page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
});
function Pe(o, t) {
  const e = t - o + 1;
  return Array.from({ length: e }, (n, s) => s + o);
}
function ii(o) {
  return o.map((t) => typeof t == "number" ? { type: "page", value: t } : { type: "ellipsis" });
}
const _t = "ellipsis";
function ri(o, t, e, n) {
  const l = t, i = Math.max(o - e, 1), r = Math.min(o + e, l), u = i > 1 + 1, d = r < l - 1;
  if (n) {
    const c = Math.min(2 * e + 5, t) - 2;
    if (!u && d)
      return [...Pe(1, c), _t, l];
    if (u && !d) {
      const m = Pe(l - c + 1, l);
      return [1, _t, ...m];
    }
    if (u && d) {
      const m = Pe(i, r);
      return [1, _t, ...m, _t, l];
    }
    return Pe(1, l);
  } else {
    const p = e * 2 + 1;
    return t < p ? Pe(1, l) : o <= e + 1 ? Pe(1, p) : t - o <= e ? Pe(t - p + 1, l) : Pe(i, r);
  }
}
const qd = /* @__PURE__ */ g({
  __name: "PaginationList",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = et(), n = S(() => ii(
      ri(
        e.page.value,
        e.pageCount.value,
        e.siblingCount.value,
        e.showEdges.value
      )
    ));
    return (s, l) => (h(), b(a(D), R(K(t)), {
      default: v(() => [
        y(s.$slots, "default", { items: n.value })
      ]),
      _: 3
    }, 16));
  }
}), Gd = /* @__PURE__ */ g({
  __name: "PaginationListItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = et(), n = S(() => e.page.value === t.value);
    return (s, l) => (h(), b(a(D), T(t, {
      "data-type": "page",
      "aria-label": `Page ${s.value}`,
      "aria-current": n.value ? "page" : void 0,
      "data-selected": n.value ? "true" : void 0,
      disabled: a(e).disabled.value,
      type: s.as === "button" ? "button" : void 0,
      onClick: l[0] || (l[0] = (i) => a(e).onPageChange(s.value))
    }), {
      default: v(() => [
        y(s.$slots, "default", {}, () => [
          ue(Ke(s.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-current", "data-selected", "disabled", "type"]));
  }
}), Yd = /* @__PURE__ */ g({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = et();
    return (n, s) => (h(), b(a(D), T(t, {
      "aria-label": "Next Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: a(e).page.value === a(e).pageCount.value || a(e).disabled.value,
      onClick: s[0] || (s[0] = (l) => a(e).onPageChange(a(e).page.value + 1))
    }), {
      default: v(() => [
        y(n.$slots, "default", {}, () => [
          ue("Next page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
}), Xd = /* @__PURE__ */ g({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = et();
    return (n, s) => {
      var l;
      return h(), b(a(D), T(t, {
        "aria-label": "Previous Page",
        type: n.as === "button" ? "button" : void 0,
        disabled: a(e).page.value === 1 || ((l = a(e).disabled) == null ? void 0 : l.value),
        onClick: s[0] || (s[0] = (i) => a(e).onPageChange(a(e).page.value - 1))
      }), {
        default: v(() => [
          y(n.$slots, "default", {}, () => [
            ue("Prev page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
}), ui = ["id", "value", "name", "disabled", "required"], [di, ci] = W("PinInputRoot"), Jd = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "PinInputRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    placeholder: { default: "" },
    mask: { type: Boolean },
    otp: { type: Boolean },
    type: { default: "text" },
    dir: {},
    name: {},
    disabled: { type: Boolean },
    required: { type: Boolean },
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "complete"],
  setup(o, { emit: t }) {
    const e = o, n = t, { mask: s, otp: l, placeholder: i, type: r, disabled: u, dir: d } = U(e), p = de(d), c = J(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? [],
      passive: e.modelValue === void 0
    }), f = $(/* @__PURE__ */ new Set());
    function m(w) {
      f.value.add(w);
    }
    const C = S(() => c.value.filter((P) => !!P).length === f.value.size);
    return X(c, () => {
      C.value && n("complete", c.value);
    }, { deep: !0 }), ci({
      modelValue: c,
      mask: s,
      otp: l,
      placeholder: i,
      type: r,
      dir: p,
      disabled: u,
      isCompleted: C,
      inputElements: f,
      onInputElementChange: m
    }), (w, P) => (h(), Z(ie, null, [
      M(a(D), T(w.$attrs, {
        dir: a(p),
        "data-complete": C.value ? "" : void 0,
        "data-disabled": a(u) ? "" : void 0
      }), {
        default: v(() => [
          y(w.$slots, "default", { modelValue: a(c) })
        ]),
        _: 3
      }, 16, ["dir", "data-complete", "data-disabled"]),
      rt("input", {
        id: w.id,
        type: "text",
        tabindex: "-1",
        "aria-hidden": "",
        value: a(c).join(""),
        name: w.name,
        disabled: a(u),
        required: w.required,
        style: ae({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }),
        onFocus: P[0] || (P[0] = (_) => {
          var E, x;
          return (x = (E = Array.from(f.value)) == null ? void 0 : E[0]) == null ? void 0 : x.focus();
        })
      }, null, 44, ui)
    ], 64));
  }
}), pi = ["autocomplete", "type", "inputmode", "pattern", "placeholder", "value", "disabled", "data-disabled", "data-complete", "aria-label"], Zd = /* @__PURE__ */ g({
  __name: "PinInputInput",
  props: {
    index: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(o) {
    const t = o, e = di(), n = S(() => Array.from(e.inputElements.value)), s = S(() => t.disabled || e.disabled.value), l = S(() => e.otp.value), i = S(() => e.type.value === "number"), r = S(() => e.mask.value), u = $();
    function d(_) {
      const E = _.target;
      if (i.value && !/^[0-9]*$/.test(E.value)) {
        E.value = E.value.replace(/\D/g, "");
        return;
      }
      E.value = E.value.slice(-1), P(t.index, E.value);
      const x = n.value[t.index + 1];
      x && x.focus();
    }
    function p(_) {
      Ye(_, document.activeElement, void 0, {
        itemsArray: n.value,
        focus: !0,
        loop: !1,
        arrowKeyOptions: "horizontal",
        dir: e.dir.value
      });
    }
    function c(_) {
      if (_.preventDefault(), _.target.value)
        P(t.index, "");
      else {
        const B = n.value[t.index - 1];
        B && (B.focus(), P(t.index - 1, ""));
      }
    }
    function f(_) {
      _.key === "Delete" && (_.preventDefault(), P(t.index, ""));
    }
    function m(_) {
      const E = _.target;
      E.setSelectionRange(1, 1), E.value || (E.placeholder = "");
    }
    function C(_) {
      const E = _.target;
      Y(() => {
        E.value || (E.placeholder = e.placeholder.value);
      });
    }
    function w(_) {
      var V;
      _.preventDefault();
      const E = _.clipboardData;
      if (!E)
        return;
      const x = [...e.modelValue.value], B = E.getData("text"), I = B.length >= n.value.length ? 0 : t.index, A = Math.min(I + B.length, n.value.length);
      for (let k = I; k < A; k++) {
        const N = n.value[k], O = B[k - I];
        i.value && !/^[0-9]*$/.test(O) || (x[k] = O, N.focus());
      }
      e.modelValue.value = x, (V = n.value[A]) == null || V.focus();
    }
    function P(_, E) {
      const x = [...e.modelValue.value];
      x[_] = E, e.modelValue.value = x;
    }
    return q(() => {
      e.onInputElementChange(u.value);
    }), fe(() => {
      var _;
      (_ = e.inputElements) == null || _.value.delete(u.value);
    }), (_, E) => (h(), Z("input", {
      ref_key: "inputRef",
      ref: u,
      autocapitalize: "none",
      autocomplete: l.value ? "one-time-code" : "false",
      type: r.value ? "password" : "text",
      inputmode: i.value ? "numeric" : "text",
      pattern: i.value ? "[0-9]*" : void 0,
      placeholder: a(e).placeholder.value,
      value: a(e).modelValue.value.at(_.index),
      disabled: s.value,
      "data-disabled": s.value ? "" : void 0,
      "data-complete": a(e).isCompleted.value ? "" : void 0,
      "aria-label": `pin input ${_.index + 1} of ${n.value.length}`,
      onInput: d,
      onKeydown: [
        le(p, ["left", "right", "up", "down", "home", "end"]),
        le(c, ["backspace"]),
        le(f, ["delete"])
      ],
      onFocus: m,
      onBlur: C,
      onPaste: w
    }, null, 40, pi));
  }
}), [ze, fi] = W("PopoverRoot"), Qd = /* @__PURE__ */ g({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { modal: s } = U(e), l = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), i = $(), r = $(!1);
    return fi({
      contentId: te(),
      modal: s,
      open: l,
      onOpenChange: (u) => {
        l.value = u;
      },
      onOpenToggle: () => {
        l.value = !l.value;
      },
      triggerElement: i,
      hasCustomAnchor: r
    }), (u, d) => (h(), b(a(He), null, {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), ec = /* @__PURE__ */ g({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o, { expose: t }) {
    const e = o, n = ze(), { primitiveElement: s, currentElement: l } = F();
    return q(() => {
      n.triggerElement.value = l.value;
    }), t({ $el: l }), (i, r) => (h(), b(_e(a(n).hasCustomAnchor.value ? a(D) : a(We)), { "as-child": "" }, {
      default: v(() => [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: s,
          type: i.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": a(n).open.value,
          "aria-controls": a(n).contentId,
          "data-state": a(n).open.value ? "open" : "closed",
          as: i.as,
          "as-child": e.asChild,
          onClick: a(n).onOpenToggle
        }, {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), tc = /* @__PURE__ */ g({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jn = /* @__PURE__ */ g({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Ot(e), l = ze();
    return bo(), (i, r) => (h(), b(a(At), {
      "as-child": "",
      loop: "",
      trapped: i.trapFocus,
      onMountAutoFocus: r[5] || (r[5] = (u) => n("openAutoFocus", u)),
      onUnmountAutoFocus: r[6] || (r[6] = (u) => n("closeAutoFocus", u))
    }, {
      default: v(() => [
        M(a(De), {
          "as-child": "",
          "disable-outside-pointer-events": i.disableOutsidePointerEvents,
          onPointerDownOutside: r[0] || (r[0] = (u) => n("pointerDownOutside", u)),
          onInteractOutside: r[1] || (r[1] = (u) => n("interactOutside", u)),
          onEscapeKeyDown: r[2] || (r[2] = (u) => n("escapeKeyDown", u)),
          onFocusOutside: r[3] || (r[3] = (u) => n("focusOutside", u)),
          onDismiss: r[4] || (r[4] = (u) => a(l).onOpenChange(!1))
        }, {
          default: v(() => [
            M(a(Fe), T(a(s), {
              id: a(l).contentId,
              "data-state": a(l).open.value ? "open" : "closed",
              role: "dialog",
              style: {
                "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
              }
            }), {
              default: v(() => [
                y(i.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), vi = /* @__PURE__ */ g({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ze(), l = $(!1);
    pt(!0);
    const i = pe(e, n), { primitiveElement: r, currentElement: u } = F();
    return ft(u), (d, p) => (h(), b(Jn, T({
      ref_key: "primitiveElement",
      ref: r
    }, a(i), {
      "trap-focus": a(s).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: p[0] || (p[0] = oe(
        (c) => {
          var f;
          n("closeAutoFocus", c), l.value || (f = a(s).triggerElement.value) == null || f.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: p[1] || (p[1] = (c) => {
        n("pointerDownOutside", c);
        const f = c.detail.originalEvent, m = f.button === 0 && f.ctrlKey === !0, C = f.button === 2 || m;
        l.value = C;
      }),
      onFocusOutside: p[2] || (p[2] = oe(() => {
      }, ["prevent"]))
    }), {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), mi = /* @__PURE__ */ g({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ze(), l = $(!1), i = $(!1), r = pe(e, n);
    return (u, d) => (h(), b(Jn, T(a(r), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: d[0] || (d[0] = (p) => {
        var c;
        n("closeAutoFocus", p), p.defaultPrevented || (l.value || (c = a(s).triggerElement.value) == null || c.focus(), p.preventDefault()), l.value = !1, i.value = !1;
      }),
      onInteractOutside: d[1] || (d[1] = async (p) => {
        var m;
        n("interactOutside", p), p.defaultPrevented || (l.value = !0, p.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const c = p.target;
        ((m = a(s).triggerElement.value) == null ? void 0 : m.contains(c)) && p.preventDefault(), p.detail.originalEvent.type === "focusin" && i.value && p.preventDefault();
      })
    }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), oc = /* @__PURE__ */ g({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ze(), l = pe(e, n);
    return (i, r) => (h(), b(a(se), {
      present: i.forceMount || a(s).open.value
    }, {
      default: v(() => [
        a(s).modal.value ? (h(), b(vi, R(T({ key: 0 }, a(l))), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16)) : (h(), b(mi, R(T({ key: 1 }, a(l))), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), nc = /* @__PURE__ */ g({
  __name: "PopoverArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Xe), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ac = /* @__PURE__ */ g({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ze();
    return (n, s) => (h(), b(a(D), {
      type: n.as === "button" ? "button" : void 0,
      as: n.as,
      "as-child": t.asChild,
      onClick: s[0] || (s[0] = (l) => a(e).onOpenChange(!1))
    }, {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as", "as-child"]));
  }
}), sc = /* @__PURE__ */ g({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = ze();
    return bn(() => {
      e.hasCustomAnchor.value = !0;
    }), fe(() => {
      e.hasCustomAnchor.value = !1;
    }), (n, s) => (h(), b(a(We), R(K(t)), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), lt = 100, [hi, yi] = W("ProgressRoot"), Go = (o) => typeof o == "number";
function gi(o, t) {
  return o === null || Go(o) && !Number.isNaN(o) && o <= t && o >= 0 ? o : (console.error(`Invalid prop \`value\` of value \`${o}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${lt} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function bi(o) {
  return Go(o) && !Number.isNaN(o) && o > 0 ? o : (console.error(
    `Invalid prop \`max\` of value \`${o}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${lt}\`.`
  ), lt);
}
const lc = /* @__PURE__ */ g({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: lt },
    getValueLabel: { type: Function, default: (o, t) => `${Math.round(o / t * lt)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = J(e, "modelValue", n, {
      passive: e.modelValue === void 0
    }), l = J(e, "max", n, {
      passive: e.max === void 0
    });
    X(
      () => s.value,
      async (r) => {
        const u = gi(r, e.max);
        u !== r && (await Y(), s.value = u);
      },
      { immediate: !0 }
    ), X(
      () => e.max,
      (r) => {
        const u = bi(e.max);
        u !== r && (l.value = u);
      },
      { immediate: !0 }
    );
    const i = S(() => s.value ? s.value === l.value ? "complete" : "loading" : "indeterminate");
    return yi({
      modelValue: s,
      max: l,
      progressState: i
    }), (r, u) => (h(), b(a(D), {
      "as-child": e.asChild,
      as: r.as,
      "aria-valuemax": a(l),
      "aria-valuemin": 0,
      "aria-valuenow": Go(a(s)) ? a(s) : void 0,
      "aria-valuetext": r.getValueLabel(a(s), a(l)),
      "aria-label": r.getValueLabel(a(s), a(l)),
      role: "progressbar",
      "data-state": i.value,
      "data-value": a(s) ?? void 0,
      "data-max": a(l)
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]));
  }
}), ic = /* @__PURE__ */ g({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = hi();
    return (n, s) => {
      var l;
      return h(), b(a(D), T(t, {
        "data-state": a(e).progressState.value,
        "data-value": ((l = a(e).modelValue) == null ? void 0 : l.value) ?? void 0,
        "data-max": a(e).max.value
      }), {
        default: v(() => [
          y(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
}), [Ci, _i] = W("RadioGroupRoot"), rc = /* @__PURE__ */ g({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: !1 },
    name: {},
    required: { type: Boolean, default: !1 },
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), { disabled: l, loop: i, orientation: r, name: u, required: d, dir: p } = U(e), c = de(p);
    return _i({
      modelValue: s,
      changeModelValue: (f) => {
        s.value = f;
      },
      disabled: l,
      loop: i,
      orientation: r,
      name: u == null ? void 0 : u.value,
      required: d
    }), (f, m) => (h(), b(a(Ze), {
      "as-child": "",
      orientation: a(r),
      dir: a(c),
      loop: a(i)
    }, {
      default: v(() => [
        M(a(D), {
          role: "radiogroup",
          "data-disabled": a(l) ? "" : void 0,
          "as-child": f.asChild,
          as: f.as,
          required: a(d),
          "aria-orientation": a(r),
          "aria-required": a(d),
          dir: a(c),
          name: a(u)
        }, {
          default: v(() => [
            y(f.$slots, "default")
          ]),
          _: 3
        }, 8, ["data-disabled", "as-child", "as", "required", "aria-orientation", "aria-required", "dir", "name"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), wi = ["value", "checked", "name", "disabled", "required"], Ei = /* @__PURE__ */ g({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "checked", t, {
      passive: e.checked === void 0
    }), { value: l } = U(e), { primitiveElement: i, currentElement: r } = F(), u = Ne(r), d = S(() => {
      var c;
      return e.id && r.value ? ((c = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : c.innerText) ?? e.value : void 0;
    });
    function p(c) {
      s.value = !0, u.value && c.stopPropagation();
    }
    return (c, f) => (h(), b(a(D), T(c.$attrs, {
      id: c.id,
      ref_key: "primitiveElement",
      ref: i,
      role: "radio",
      type: c.as === "button" ? "button" : void 0,
      as: c.as,
      "aria-checked": a(s),
      "aria-label": d.value,
      "as-child": c.asChild,
      disabled: c.disabled ? !0 : void 0,
      "data-state": a(s) ? "checked" : "unchecked",
      "data-disabled": c.disabled ? "" : void 0,
      value: a(l),
      required: c.required,
      name: c.name,
      onClick: oe(p, ["stop"])
    }), {
      default: v(() => [
        y(c.$slots, "default"),
        a(u) ? (h(), Z("input", {
          key: 0,
          type: "radio",
          tabindex: "-1",
          "aria-hidden": "",
          value: a(l),
          checked: !!a(s),
          name: c.name,
          disabled: c.disabled,
          required: c.required,
          style: ae({
            transform: "translateX(-100%)",
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          })
        }, null, 12, wi)) : G("", !0)
      ]),
      _: 3
    }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name"]));
  }
}), [xi, $i] = W("RadioGroupItem"), uc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = F(), s = Ci(), l = S(() => s.disabled.value || t.disabled), i = S(() => s.required.value || t.required), r = S(() => {
      var c;
      return ((c = s.modelValue) == null ? void 0 : c.value) === t.value;
    });
    $i({ disabled: l, checked: r });
    const u = $(!1), d = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    Se("keydown", (c) => {
      d.includes(c.key) && (u.value = !0);
    }), Se("keyup", () => {
      u.value = !1;
    });
    function p() {
      setTimeout(() => {
        var c;
        u.value && ((c = n.value) == null || c.click());
      }, 0);
    }
    return (c, f) => (h(), b(a(Qe), {
      checked: r.value,
      disabled: l.value,
      "as-child": "",
      focusable: !l.value,
      active: r.value
    }, {
      default: v(() => [
        M(Ei, T({
          ref_key: "primitiveElement",
          ref: e
        }, { ...c.$attrs, ...t }, {
          checked: r.value,
          required: i.value,
          "onUpdate:checked": f[0] || (f[0] = (m) => a(s).changeModelValue(c.value)),
          onKeydown: f[1] || (f[1] = le(oe(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: p
        }), {
          default: v(() => [
            y(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["checked", "required"])
      ]),
      _: 3
    }, 8, ["checked", "disabled", "focusable", "active"]));
  }
}), dc = /* @__PURE__ */ g({
  __name: "RadioGroupIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = xi();
    return (e, n) => a(t).checked.value ? (h(), b(a(D), {
      key: 0,
      "data-state": a(t).checked.value ? "checked" : "unchecked",
      "data-disabled": a(t).disabled.value ? "" : void 0,
      "as-child": e.asChild,
      as: e.as
    }, {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "data-disabled", "as-child", "as"])) : G("", !0);
  }
}), [me, Pi] = W("ScrollAreaRoot"), cc = /* @__PURE__ */ g({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = F(), s = $(0), l = $(0), i = $(), r = $(), u = $(), d = $(), p = $(!1), c = $(!1), { type: f, dir: m, scrollHideDelay: C } = U(t), w = de(m);
    return Pi({
      type: f,
      dir: w,
      scrollHideDelay: C,
      scrollArea: n,
      viewport: i,
      onViewportChange: (P) => {
        i.value = P || void 0;
      },
      content: r,
      onContentChange: (P) => {
        r.value = P;
      },
      scrollbarX: u,
      scrollbarXEnabled: p,
      scrollbarY: d,
      scrollbarYEnabled: c,
      onScrollbarXChange: (P) => {
        u.value = P || void 0;
      },
      onScrollbarYChange: (P) => {
        d.value = P || void 0;
      },
      onScrollbarXEnabledChange: (P) => {
        p.value = P;
      },
      onScrollbarYEnabledChange: (P) => {
        c.value = P;
      },
      onCornerWidthChange: (P) => {
        s.value = P;
      },
      onCornerHeightChange: (P) => {
        l.value = P;
      }
    }), (P, _) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: e,
      "as-child": t.asChild,
      as: P.as,
      dir: a(w),
      style: ae({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        "--radix-scroll-area-corner-width": `${s.value}px`,
        "--radix-scroll-area-corner-height": `${l.value}px`
      })
    }, {
      default: v(() => [
        y(P.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
}), pc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ScrollAreaViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), { primitiveElement: n, currentElement: s } = F(), l = $();
    return q(() => {
      e.onViewportChange(l.value), e.onContentChange(s.value);
    }), (i, r) => (h(), Z(ie, null, [
      rt("div", T({
        ref_key: "viewportElement",
        ref: l,
        "data-radix-scroll-area-viewport": "",
        style: {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: a(e).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: a(e).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, i.$attrs, { tabindex: 0 }), [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: n,
          style: { minWidth: "100%", display: "table" },
          "as-child": t.asChild,
          as: i.as
        }, {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ], 16),
      M(a(D), { as: "style" }, {
        default: v(() => [
          ue(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
        ]),
        _: 1
      })
    ], 64));
  }
});
function Bi(o, [t, e]) {
  return Math.min(e, Math.max(t, o));
}
function Zn(o, t) {
  return (e) => {
    if (o[0] === o[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (o[1] - o[0]);
    return t[0] + n * (e - o[0]);
  };
}
function Ft(o) {
  const t = Qn(o.viewport, o.content), e = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, n = (o.scrollbar.size - e) * t;
  return Math.max(n, 18);
}
function Qn(o, t) {
  const e = o / t;
  return Number.isNaN(e) ? 0 : e;
}
function Si(o, t = () => {
}) {
  let e = { left: o.scrollLeft, top: o.scrollTop }, n = 0;
  return function s() {
    const l = { left: o.scrollLeft, top: o.scrollTop }, i = e.left !== l.left, r = e.top !== l.top;
    (i || r) && t(), e = l, n = window.requestAnimationFrame(s);
  }(), () => window.cancelAnimationFrame(n);
}
function rn(o, t, e = "ltr") {
  const n = Ft(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, l = t.scrollbar.size - s, i = t.content - t.viewport, r = l - n, u = e === "ltr" ? [0, i] : [i * -1, 0], d = Bi(
    o,
    u
  );
  return Zn([0, i], [0, r])(d);
}
function wt(o) {
  return o ? Number.parseInt(o, 10) : 0;
}
function Ti(o, t, e, n = "ltr") {
  const s = Ft(e), l = s / 2, i = t || l, r = s - i, u = e.scrollbar.paddingStart + i, d = e.scrollbar.size - e.scrollbar.paddingEnd - r, p = e.content - e.viewport, c = n === "ltr" ? [0, p] : [p * -1, 0];
  return Zn(
    [u, d],
    c
  )(o);
}
function un(o, t) {
  return o > 0 && o < t;
}
const ea = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = me(), l = Lt(), i = Kt(), { primitiveElement: r, currentElement: u } = F(), d = be(), p = $(""), c = $();
    function f(E) {
      var x, B;
      if (c.value) {
        const I = E.clientX - ((x = c.value) == null ? void 0 : x.left), A = E.clientY - ((B = c.value) == null ? void 0 : B.top);
        n("onDragScroll", { x: I, y: A });
      }
    }
    function m(E) {
      E.button === 0 && (E.target.setPointerCapture(E.pointerId), c.value = u.value.getBoundingClientRect(), p.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", s.viewport && (s.viewport.value.style.scrollBehavior = "auto"), f(E));
    }
    function C(E) {
      f(E);
    }
    function w(E) {
      const x = E.target;
      x.hasPointerCapture(E.pointerId) && x.releasePointerCapture(E.pointerId), document.body.style.webkitUserSelect = p.value, s.viewport && (s.viewport.value.style.scrollBehavior = ""), c.value = void 0;
    }
    function P(E) {
      var A;
      const x = E.target, B = (A = u.value) == null ? void 0 : A.contains(x), I = l.sizes.value.content - l.sizes.value.viewport;
      B && l.handleWheelScroll(E, I);
    }
    q(() => {
      document.addEventListener("wheel", P, { passive: !1 });
    }), fe(() => {
      document.removeEventListener("wheel", P);
    });
    function _() {
      var E, x, B, I, A;
      u.value && (e.isHorizontal ? l.handleSizeChange({
        content: ((E = s.viewport.value) == null ? void 0 : E.scrollWidth) ?? 0,
        viewport: ((x = s.viewport.value) == null ? void 0 : x.offsetWidth) ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: wt(getComputedStyle(u.value).paddingLeft),
          paddingEnd: wt(getComputedStyle(u.value).paddingRight)
        }
      }) : l.handleSizeChange({
        content: ((B = s.viewport.value) == null ? void 0 : B.scrollHeight) ?? 0,
        viewport: ((I = s.viewport.value) == null ? void 0 : I.offsetHeight) ?? 0,
        scrollbar: {
          size: ((A = u.value) == null ? void 0 : A.clientHeight) ?? 0,
          paddingStart: wt(getComputedStyle(u.value).paddingLeft),
          paddingEnd: wt(getComputedStyle(u.value).paddingRight)
        }
      }));
    }
    return we(u, _), we(s.content, _), (E, x) => (h(), b(a(D), {
      ref: (B) => {
        a(d)(B), r.value = B;
      },
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: a(i).as.value,
      "as-child": a(i).asChild.value,
      onPointerdown: m,
      onPointermove: C,
      onPointerup: w
    }, {
      default: v(() => [
        y(E.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Di = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarX",
  setup(o) {
    const t = me(), e = Lt(), { primitiveElement: n, currentElement: s } = F(), l = be();
    q(() => {
      s.value && t.onScrollbarXChange(s.value);
    });
    const i = S(() => e.sizes.value);
    return (r, u) => (h(), b(ea, {
      ref: (d) => {
        a(l)(d), n.value = d;
      },
      "is-horizontal": !0,
      "data-orientation": "horizontal",
      style: ae({
        bottom: 0,
        left: a(t).dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: a(t).dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": i.value ? `${a(Ft)(i.value)}px` : void 0
      }),
      onOnDragScroll: u[0] || (u[0] = (d) => a(e).onDragScroll(d.x))
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), Oi = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarY",
  setup(o) {
    const t = me(), e = Lt(), { primitiveElement: n, currentElement: s } = F(), l = be();
    q(() => {
      s.value && t.onScrollbarYChange(s.value);
    });
    const i = S(() => e.sizes.value);
    return (r, u) => (h(), b(ea, {
      ref: (d) => {
        a(l)(d), n.value = d;
      },
      "is-horizontal": !1,
      "data-orientation": "vertical",
      style: ae({
        top: 0,
        right: a(t).dir.value === "ltr" ? 0 : void 0,
        left: a(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": i.value ? `${a(Ft)(i.value)}px` : void 0
      }),
      onOnDragScroll: u[0] || (u[0] = (d) => a(e).onDragScroll(d.y))
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), [Lt, Ii] = W("ScrollAreaScrollbarVisible"), Yo = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarVisible",
  setup(o) {
    const t = me(), e = Kt(), n = be(), s = $({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), l = S(() => {
      const _ = Qn(s.value.viewport, s.value.content);
      return _ > 0 && _ < 1;
    }), i = $(), r = $(0);
    function u(_, E) {
      if (m.value) {
        const x = t.viewport.value.scrollLeft + _.deltaY;
        t.viewport.value.scrollLeft = x, un(x, E) && _.preventDefault();
      } else {
        const x = t.viewport.value.scrollTop + _.deltaY;
        t.viewport.value.scrollTop = x, un(x, E) && _.preventDefault();
      }
    }
    function d(_, E) {
      m.value ? r.value = E.x : r.value = E.y;
    }
    function p(_) {
      r.value = 0;
    }
    function c(_) {
      s.value = _;
    }
    function f(_, E) {
      return Ti(
        _,
        r.value,
        s.value,
        E
      );
    }
    const m = S(
      () => e.isHorizontal.value
    );
    function C(_) {
      m.value ? t.viewport.value.scrollLeft = f(
        _,
        t.dir.value
      ) : t.viewport.value.scrollTop = f(_);
    }
    function w() {
      if (m.value) {
        if (t.viewport.value && i.value) {
          const _ = t.viewport.value.scrollLeft, E = rn(
            _,
            s.value,
            t.dir.value
          );
          i.value.style.transform = `translate3d(${E}px, 0, 0)`;
        }
      } else if (t.viewport.value && i.value) {
        const _ = t.viewport.value.scrollTop, E = rn(_, s.value);
        i.value.style.transform = `translate3d(0, ${E}px, 0)`;
      }
    }
    function P(_) {
      i.value = _;
    }
    return Ii({
      sizes: s,
      hasThumb: l,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: p,
      handleSizeChange: c,
      onThumbPositionChange: w,
      onThumbChange: P,
      onDragScroll: C
    }), (_, E) => m.value ? (h(), b(Di, T({ key: 0 }, _.$attrs, {
      ref_key: "forwardRef",
      ref: n
    }), {
      default: v(() => [
        y(_.$slots, "default")
      ]),
      _: 3
    }, 16)) : (h(), b(Oi, T({ key: 1 }, _.$attrs, {
      ref_key: "forwardRef",
      ref: n
    }), {
      default: v(() => [
        y(_.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ta = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = Kt(), n = be(), s = $(!1), l = ho(() => {
      if (t.viewport.value) {
        const i = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, r = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        s.value = e.isHorizontal.value ? i : r;
      }
    }, 10);
    return q(() => l()), we(t.viewport, l), we(t.content, l), (i, r) => (h(), b(a(se), {
      present: i.forceMount || s.value
    }, {
      default: v(() => [
        M(Yo, T(i.$attrs, {
          ref_key: "forwardRef",
          ref: n,
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Ai = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = be();
    let n;
    const s = $(!1);
    function l() {
      window.clearTimeout(n), s.value = !0;
    }
    function i() {
      n = window.setTimeout(() => {
        s.value = !1;
      }, t.scrollHideDelay.value);
    }
    return q(() => {
      const r = t.scrollArea.value;
      r && (r.addEventListener("pointerenter", l), r.addEventListener("pointerleave", i));
    }), fe(() => {
      const r = t.scrollArea.value;
      r && (window.clearTimeout(n), r.removeEventListener("pointerenter", l), r.removeEventListener("pointerleave", i));
    }), (r, u) => (h(), b(a(se), {
      present: r.forceMount || s.value
    }, {
      default: v(() => [
        M(ta, T(r.$attrs, {
          ref_key: "forwardRef",
          ref: e,
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: v(() => [
            y(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Mi = /* @__PURE__ */ g({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = Kt(), n = be(), { state: s, dispatch: l } = $n("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    Q(() => {
      s.value === "idle" && window.setTimeout(
        () => l("HIDE"),
        t.scrollHideDelay.value
      );
    });
    const i = ho(() => l("SCROLL_END"), 100);
    return Q(() => {
      const r = t.viewport.value, u = e.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (r) {
        let d = r[u];
        const p = () => {
          const c = r[u];
          d !== c && (l("SCROLL"), i()), d = c;
        };
        r.addEventListener("scroll", p);
      }
    }), (r, u) => (h(), b(a(se), {
      present: r.forceMount || a(s) !== "hidden"
    }, {
      default: v(() => [
        M(Yo, T(r.$attrs, {
          ref_key: "forwardRef",
          ref: n
        }), {
          default: v(() => [
            y(r.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [Kt, ki] = W("ScrollAreaScrollbar"), fc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = me(), n = S(() => t.orientation === "horizontal");
    X(
      n,
      () => {
        n.value ? e.onScrollbarXEnabledChange(!0) : e.onScrollbarYEnabledChange(!0);
      },
      { immediate: !0 }
    ), fe(() => {
      e.onScrollbarXEnabledChange(!1), e.onScrollbarYEnabledChange(!1);
    });
    const { orientation: s, forceMount: l, asChild: i, as: r } = U(t);
    return ki({
      orientation: s,
      forceMount: l,
      isHorizontal: n,
      as: r,
      asChild: i
    }), (u, d) => a(e).type.value === "hover" ? (h(), b(Ai, T({ key: 0 }, u.$attrs, { "force-mount": a(l) }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : a(e).type.value === "scroll" ? (h(), b(Mi, T({ key: 1 }, u.$attrs, { "force-mount": a(l) }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : a(e).type.value === "auto" ? (h(), b(ta, T({ key: 2 }, u.$attrs, { "force-mount": a(l) }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : a(e).type.value === "always" ? (h(), b(Yo, T({ key: 3 }, u.$attrs, { "data-state": "visible" }), {
      default: v(() => [
        y(u.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), vc = /* @__PURE__ */ g({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), n = Lt();
    function s(f) {
      const C = f.target.getBoundingClientRect(), w = f.clientX - C.left, P = f.clientY - C.top;
      n.handleThumbDown(f, { x: w, y: P });
    }
    function l(f) {
      n.handleThumbUp(f);
    }
    const { primitiveElement: i, currentElement: r } = F(), u = $(), d = S(() => e.viewport.value);
    function p() {
      if (!u.value) {
        const f = Si(
          d.value,
          n.onThumbPositionChange
        );
        u.value = f, n.onThumbPositionChange();
      }
    }
    const c = S(() => n.sizes.value);
    return ts(c, () => {
      n.onThumbChange(r.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener("scroll", p));
    }), fe(() => {
      var f;
      d.value.removeEventListener("scroll", p), (f = e.viewport.value) == null || f.removeEventListener("scroll", p);
    }), (f, m) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: i,
      "data-state": a(n).hasThumb ? "visible" : "hidden",
      style: ae({
        width: "var(--radix-scroll-area-thumb-width)",
        height: "var(--radix-scroll-area-thumb-height)"
      }),
      "as-child": t.asChild,
      as: f.as,
      onPointerdown: s,
      onPointerup: l
    }, {
      default: v(() => [
        y(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "style", "as-child", "as"]));
  }
}), Ri = /* @__PURE__ */ g({
  __name: "ScrollAreaCornerImpl",
  setup(o) {
    const t = me(), e = $(0), n = $(0), s = S(() => !!e.value && !!n.value);
    function l() {
      var u;
      const r = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;
      t.onCornerHeightChange(r), n.value = r;
    }
    function i() {
      var u;
      const r = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;
      t.onCornerWidthChange(r), e.value = r;
    }
    return we(t.scrollbarX.value, l), we(t.scrollbarY.value, i), X(() => t.scrollbarX.value, l), X(() => t.scrollbarY.value, i), (r, u) => {
      var d;
      return s.value ? (h(), b(a(D), T({
        key: 0,
        style: {
          width: `${e.value}px`,
          height: `${n.value}px`,
          position: "absolute",
          right: a(t).dir.value === "ltr" ? 0 : void 0,
          left: a(t).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (d = r.$parent) == null ? void 0 : d.$props), {
        default: v(() => [
          y(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : G("", !0);
    };
  }
}), mc = /* @__PURE__ */ g({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), n = S(
      () => !!e.scrollbarX.value && !!e.scrollbarY.value
    ), s = S(
      () => e.type.value !== "scroll" && n.value
    );
    return (l, i) => s.value ? (h(), b(Ri, R(T({ key: 0 }, t)), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), Vi = ["default-value"], Fi = /* @__PURE__ */ g({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(o) {
    const t = o, { value: e } = U(t);
    rs(e);
    const n = $();
    return (s, l) => (h(), b(a(Je), { "as-child": "" }, {
      default: v(() => [
        po(rt("select", T({
          ref_key: "selectElement",
          ref: n
        }, t, {
          "onUpdate:modelValue": l[0] || (l[0] = (i) => ut(e) ? e.value = i : null),
          "default-value": a(e)
        }), [
          y(s.$slots, "default")
        ], 16, Vi), [
          [Ra, a(e)]
        ])
      ]),
      _: 3
    }));
  }
}), Li = {
  key: 0,
  value: ""
}, [Ie, oa] = W("SelectRoot"), [Ki, Ni] = W("SelectRoot"), hc = /* @__PURE__ */ g({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    orientation: { default: "vertical" },
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = J(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), l = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), i = $(), r = $(), u = $({
      x: 0,
      y: 0
    }), d = $(!1), { required: p, disabled: c, dir: f } = U(e), m = de(f);
    oa({
      triggerElement: i,
      onTriggerChange: (_) => {
        i.value = _;
      },
      valueElement: r,
      onValueElementChange: (_) => {
        r.value = _;
      },
      valueElementHasChildren: d,
      onValueElementHasChildrenChange: (_) => {
        d.value = _;
      },
      contentId: te(),
      modelValue: s,
      onValueChange: (_) => {
        s.value = _;
      },
      open: l,
      required: p,
      onOpenChange: (_) => {
        l.value = _;
      },
      dir: m,
      triggerPointerDownPosRef: u,
      disabled: c
    });
    const C = Ne(i), w = $(/* @__PURE__ */ new Set()), P = S(() => Array.from(w.value).map((_) => {
      var E;
      return (E = _.props) == null ? void 0 : E.value;
    }).join(";"));
    return Ni({
      onNativeOptionAdd: (_) => {
        w.value.add(_);
      },
      onNativeOptionRemove: (_) => {
        w.value.delete(_);
      }
    }), (_, E) => (h(), b(a(He), null, {
      default: v(() => [
        y(_.$slots, "default"),
        a(C) ? (h(), b(Fi, T({ key: P.value }, _.$attrs, {
          "aria-hidden": "",
          tabindex: "-1",
          required: a(p),
          name: _.name,
          autocomplete: _.autocomplete,
          disabled: a(c),
          value: a(s),
          onChange: E[0] || (E[0] = (x) => s.value = x.target.value)
        }), {
          default: v(() => [
            a(s) === void 0 ? (h(), Z("option", Li)) : G("", !0),
            (h(!0), Z(ie, null, co(Array.from(w.value), (x) => (h(), b(_e(x), T(x.props, {
              key: x.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : G("", !0)
      ]),
      _: 3
    }));
  }
}), Hi = [" ", "Enter", "ArrowUp", "ArrowDown"], Wi = [" ", "Enter"], Ce = 10;
function na(o) {
  return o === "" || o === void 0;
}
const yc = /* @__PURE__ */ g({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Ie(), n = S(() => {
      var f;
      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;
    }), { primitiveElement: s, currentElement: l } = F();
    q(() => {
      e.triggerElement = l;
    });
    const { injectCollection: i } = re(), r = i(), { search: u, handleTypeaheadSearch: d, resetTypeahead: p } = Co(r);
    function c() {
      n.value || (e.onOpenChange(!0), p());
    }
    return (f, m) => (h(), b(a(We), { "as-child": "" }, {
      default: v(() => {
        var C, w, P, _;
        return [
          M(a(D), {
            ref_key: "primitiveElement",
            ref: s,
            role: "combobox",
            type: f.as === "button" ? "button" : void 0,
            "aria-controls": a(e).contentId,
            "aria-expanded": a(e).open.value || !1,
            "aria-required": (C = a(e).required) == null ? void 0 : C.value,
            "aria-autocomplete": "none",
            disabled: f.disabled,
            dir: (w = a(e)) == null ? void 0 : w.dir.value,
            "data-state": (P = a(e)) != null && P.open.value ? "open" : "closed",
            "data-disabled": n.value ? "" : void 0,
            "data-placeholder": a(na)((_ = a(e).modelValue) == null ? void 0 : _.value) ? "" : void 0,
            "as-child": f.asChild,
            as: f.as,
            onClick: m[0] || (m[0] = (E) => {
              var x;
              (x = E == null ? void 0 : E.currentTarget) == null || x.focus();
            }),
            onPointerdown: m[1] || (m[1] = (E) => {
              const x = E.target;
              x.hasPointerCapture(E.pointerId) && x.releasePointerCapture(E.pointerId), E.button === 0 && E.ctrlKey === !1 && (c(), a(e).triggerPointerDownPosRef.value = {
                x: Math.round(E.pageX),
                y: Math.round(E.pageY)
              }, E.preventDefault());
            }),
            onPointerup: m[2] || (m[2] = oe(() => {
            }, ["prevent"])),
            onKeydown: m[3] || (m[3] = (E) => {
              const x = a(u) !== "";
              !(E.ctrlKey || E.altKey || E.metaKey) && E.key.length === 1 && x && E.key === " " || (a(d)(E.key), a(Hi).includes(E.key) && (c(), E.preventDefault()));
            })
          }, {
            default: v(() => [
              y(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
}), gc = /* @__PURE__ */ g({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [Xo, ji] = W("SelectItemAlignedPosition"), zi = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(o, { emit: t }) {
    const e = o, n = t, { injectCollection: s } = re(), l = Ie(), i = Ae(), r = s(), u = $(!1), d = $(!0), p = $(), { primitiveElement: c, currentElement: f } = F(), { viewport: m, selectedItem: C, selectedItemText: w, focusSelectedItem: P } = i;
    function _() {
      if (l.triggerElement.value && l.valueElement.value && p.value && f.value && (m != null && m.value) && (C != null && C.value) && (w != null && w.value)) {
        const B = l.triggerElement.value.getBoundingClientRect(), I = f.value.getBoundingClientRect(), A = l.valueElement.value.getBoundingClientRect(), V = w.value.getBoundingClientRect();
        if (l.dir.value !== "rtl") {
          const Me = V.left - I.left, $e = A.left - Me, ke = B.left - $e, Re = B.width + ke, qt = Math.max(Re, I.width), Gt = window.innerWidth - Ce, Yt = en($e, Ce, Gt - qt);
          p.value.style.minWidth = `${Re}px`, p.value.style.left = `${Yt}px`;
        } else {
          const Me = I.right - V.right, $e = window.innerWidth - A.right - Me, ke = window.innerWidth - B.right - $e, Re = B.width + ke, qt = Math.max(Re, I.width), Gt = window.innerWidth - Ce, Yt = en(
            $e,
            Ce,
            Gt - qt
          );
          p.value.style.minWidth = `${Re}px`, p.value.style.right = `${Yt}px`;
        }
        const k = r.value, N = window.innerHeight - Ce * 2, O = m.value.scrollHeight, H = window.getComputedStyle(f.value), j = Number.parseInt(
          H.borderTopWidth,
          10
        ), L = Number.parseInt(H.paddingTop, 10), z = Number.parseInt(
          H.borderBottomWidth,
          10
        ), ee = Number.parseInt(
          H.paddingBottom,
          10
        ), ne = j + L + O + ee + z, Ue = Math.min(
          C.value.offsetHeight * 5,
          ne
        ), ot = window.getComputedStyle(m.value), Ea = Number.parseInt(ot.paddingTop, 10), xa = Number.parseInt(
          ot.paddingBottom,
          10
        ), ht = B.top + B.height / 2 - Ce, $a = N - ht, Ut = C.value.offsetHeight / 2, Pa = C.value.offsetTop + Ut, yt = j + L + Pa, Ba = ne - yt;
        if (yt <= ht) {
          const Me = C.value === k[k.length - 1];
          p.value.style.bottom = "0px";
          const $e = f.value.clientHeight - m.value.offsetTop - m.value.offsetHeight, ke = Math.max(
            $a,
            Ut + (Me ? xa : 0) + $e + z
          ), Re = yt + ke;
          p.value.style.height = `${Re}px`;
        } else {
          const Me = C.value === k[0];
          p.value.style.top = "0px";
          const ke = Math.max(
            ht,
            j + m.value.offsetTop + (Me ? Ea : 0) + Ut
          ) + Ba;
          p.value.style.height = `${ke}px`, m.value.scrollTop = yt - ht + m.value.offsetTop;
        }
        p.value.style.margin = `${Ce}px 0`, p.value.style.minHeight = `${Ue}px`, p.value.style.maxHeight = `${N}px`, n("placed"), requestAnimationFrame(() => u.value = !0);
      }
    }
    const E = $("");
    q(async () => {
      await Y(), _(), f.value && (E.value = window.getComputedStyle(f.value).zIndex);
    });
    function x(B) {
      B && d.value === !0 && (_(), P == null || P(), d.value = !1);
    }
    return ji({
      contentWrapper: p,
      shouldExpandOnScrollRef: u,
      onScrollButtonChange: x
    }), (B, I) => (h(), Z("div", {
      ref_key: "contentWrapperElement",
      ref: p,
      style: ae({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: E.value
      })
    }, [
      M(a(D), T({
        ref_key: "primitiveElement",
        ref: c,
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...B.$attrs, ...e }), {
        default: v(() => [
          y(B.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 4));
  }
}), Ui = /* @__PURE__ */ g({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: Ce },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const e = Ot(o);
    return (n, s) => (h(), b(a(Fe), T(a(e), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), tt = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, [Ae, qi] = W("SelectContent"), Gi = /* @__PURE__ */ g({
  __name: "SelectContentImpl",
  props: {
    position: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Ie();
    bo(), pt(!0);
    const { createCollection: l } = re(), i = $();
    ft(i);
    const r = l(i), { search: u, handleTypeaheadSearch: d } = Co(r), p = $(), c = $(), f = $(), m = $(!1), C = $(!1);
    function w() {
      c.value && i.value && no([c.value, i.value]);
    }
    X(m, () => {
      w();
    });
    const { onOpenChange: P, triggerPointerDownPosRef: _ } = s;
    Q((B) => {
      if (!i.value)
        return;
      let I = { x: 0, y: 0 };
      const A = (k) => {
        var N, O;
        I = {
          x: Math.abs(
            Math.round(k.pageX) - (((N = _.value) == null ? void 0 : N.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(k.pageY) - (((O = _.value) == null ? void 0 : O.y) ?? 0)
          )
        };
      }, V = (k) => {
        var N;
        I.x <= 10 && I.y <= 10 ? k.preventDefault() : (N = i.value) != null && N.contains(k.target) || P(!1), document.removeEventListener("pointermove", A), _.value = null;
      };
      _.value !== null && (document.addEventListener("pointermove", A), document.addEventListener("pointerup", V, {
        capture: !0,
        once: !0
      })), B(() => {
        document.removeEventListener("pointermove", A), document.removeEventListener("pointerup", V, {
          capture: !0
        });
      });
    });
    function E(B) {
      const I = B.ctrlKey || B.altKey || B.metaKey;
      if (B.key === "Tab" && B.preventDefault(), !I && B.key.length === 1 && d(B.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(B.key)) {
        let A = r.value;
        if (["ArrowUp", "End"].includes(B.key) && (A = A.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(B.key)) {
          const V = B.target, k = A.indexOf(V);
          A = A.slice(k + 1);
        }
        setTimeout(() => no(A)), B.preventDefault();
      }
    }
    const x = S(() => e.position === "popper" ? e : {});
    return qi({
      content: i,
      viewport: p,
      onViewportChange: (B) => {
        p.value = B;
      },
      itemRefCallback: (B, I, A) => {
        var N, O;
        const V = !C.value && !A;
        (((N = s.modelValue) == null ? void 0 : N.value) !== void 0 && ((O = s.modelValue) == null ? void 0 : O.value) === I || V) && (c.value = B, V && (C.value = !0));
      },
      selectedItem: c,
      selectedItemText: f,
      onItemLeave: () => {
        var B;
        (B = i.value) == null || B.focus();
      },
      itemTextRefCallback: (B, I, A) => {
        var N, O;
        const V = !C.value && !A;
        (((N = s.modelValue) == null ? void 0 : N.value) !== void 0 && ((O = s.modelValue) == null ? void 0 : O.value) === I || V) && (f.value = B);
      },
      focusSelectedItem: w,
      position: e.position,
      isPositioned: m,
      searchRef: u
    }), (B, I) => (h(), b(a(At), {
      "as-child": "",
      onMountAutoFocus: I[6] || (I[6] = oe(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: I[7] || (I[7] = (A) => {
        var V;
        n("closeAutoFocus", A), !A.defaultPrevented && ((V = a(s).triggerElement.value) == null || V.focus({ preventScroll: !0 }), A.preventDefault());
      })
    }, {
      default: v(() => [
        M(a(De), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: I[2] || (I[2] = oe(() => {
          }, ["prevent"])),
          onDismiss: I[3] || (I[3] = (A) => a(s).onOpenChange(!1)),
          onEscapeKeyDown: I[4] || (I[4] = (A) => n("escapeKeyDown", A)),
          onPointerDownOutside: I[5] || (I[5] = (A) => n("pointerDownOutside", A))
        }, {
          default: v(() => [
            (h(), b(_e(
              B.position === "popper" ? Ui : zi
            ), T({ ...B.$attrs, ...x.value }, {
              id: a(s).contentId,
              ref: (A) => {
                i.value = a(ve)(A);
              },
              role: "listbox",
              "data-state": a(s).open.value ? "open" : "closed",
              dir: a(s).dir.value,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none"
              },
              onContextmenu: I[0] || (I[0] = oe(() => {
              }, ["prevent"])),
              onPlaced: I[1] || (I[1] = (A) => m.value = !0),
              onKeydown: E
            }), {
              default: v(() => [
                y(B.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "dir", "onKeydown"]))
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), Yi = /* @__PURE__ */ g({
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(o) {
    return oa(o.context), (e, n) => y(e.$slots, "default");
  }
}), bc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "item-aligned" },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const s = pe(o, t), l = Ie(), i = $();
    q(() => {
      i.value = new DocumentFragment();
    });
    const r = $();
    return (u, d) => {
      var p;
      return h(), Z(ie, null, [
        M(a(se), {
          ref_key: "presenceRef",
          ref: r,
          present: u.forceMount || a(l).open.value
        }, {
          default: v(() => [
            M(Gi, R(K({ ...a(s), ...u.$attrs })), {
              default: v(() => [
                y(u.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 8, ["present"]),
        !((p = r.value) != null && p.present) && i.value ? (h(), b(Ge, {
          key: 0,
          to: i.value
        }, [
          M(Yi, { context: a(l) }, {
            default: v(() => [
              rt("div", null, [
                y(u.$slots, "default")
              ])
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"])) : G("", !0)
      ], 64);
    };
  }
}), Cc = /* @__PURE__ */ g({
  __name: "SelectArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ie(), n = Ae();
    return (s, l) => a(e).open.value && a(n).position === "popper" ? (h(), b(a(Xe), R(T({ key: 0 }, t)), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), _c = /* @__PURE__ */ g({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), T({ "aria-hidden": "" }, t), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [aa, Xi] = W("SelectItem"), wc = /* @__PURE__ */ g({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { disabled: e } = U(t), n = Ie(), s = Ae(tt), { primitiveElement: l, currentElement: i } = F(), r = S(() => {
      var w;
      return ((w = n.modelValue) == null ? void 0 : w.value) === t.value;
    }), u = $(!1), d = $(t.textValue ?? ""), p = te();
    async function c(w) {
      await Y(), !(w != null && w.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));
    }
    async function f(w) {
      var P;
      await Y(), !w.defaultPrevented && (e.value ? (P = s.onItemLeave) == null || P.call(s) : w.currentTarget.focus({ preventScroll: !0 }));
    }
    async function m(w) {
      var P;
      await Y(), !w.defaultPrevented && w.currentTarget === document.activeElement && ((P = s.onItemLeave) == null || P.call(s));
    }
    async function C(w) {
      var _;
      await Y(), !(w.defaultPrevented || ((_ = s.searchRef) == null ? void 0 : _.value) !== "" && w.key === " ") && (Wi.includes(w.key) && c(), w.key === " " && w.preventDefault());
    }
    if (t.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return q(() => {
      i.value && s.itemRefCallback(
        i.value,
        t.value,
        t.disabled
      );
    }), Xi({
      value: t.value,
      disabled: e,
      textId: p,
      isSelected: r,
      onItemTextChange: (w) => {
        d.value = ((d.value || (w == null ? void 0 : w.textContent)) ?? "").trim();
      }
    }), (w, P) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: l,
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": a(p),
      "data-highlighted": u.value ? "" : void 0,
      "aria-selected": r.value && u.value,
      "data-state": r.value ? "checked" : "unchecked",
      "aria-disabled": a(e) || void 0,
      "data-disabled": a(e) ? "" : void 0,
      tabindex: a(e) ? void 0 : -1,
      as: w.as,
      "as-child": w.asChild,
      onFocus: P[0] || (P[0] = (_) => u.value = !0),
      onBlur: P[1] || (P[1] = (_) => u.value = !1),
      onPointerup: c,
      onTouchend: P[2] || (P[2] = oe(() => {
      }, ["prevent", "stop"])),
      onPointermove: f,
      onPointerleave: m,
      onKeydown: C
    }, {
      default: v(() => [
        y(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
}), Ec = /* @__PURE__ */ g({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = aa();
    return (n, s) => a(e).isSelected.value ? (h(), b(a(D), T({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), [Ji, Zi] = W("SelectGroup"), xc = /* @__PURE__ */ g({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = te();
    return Zi({ id: e }), (n, s) => (h(), b(a(D), T({ role: "group" }, t, { "aria-labelledby": a(e) }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), $c = /* @__PURE__ */ g({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = Ji({ id: "" });
    return (n, s) => (h(), b(a(D), T(t, {
      id: a(e).id
    }), {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Pc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Ie(), n = Ae(tt), s = Ki(), l = aa(), { primitiveElement: i, currentElement: r } = F(), u = S(() => {
      var d;
      return Ve("option", {
        key: l.value,
        value: l.value,
        disabled: l.disabled.value,
        innerHTML: (d = r.value) == null ? void 0 : d.textContent
      });
    });
    return q(() => {
      r.value && (l.onItemTextChange(r.value), n.itemTextRefCallback(
        r.value,
        l.value,
        l.disabled.value
      ), s.onNativeOptionAdd(u.value));
    }), uo(() => {
      s.onNativeOptionRemove(u.value);
    }), (d, p) => (h(), Z(ie, null, [
      M(a(D), T({
        id: a(l).textId,
        ref_key: "primitiveElement",
        ref: i
      }, { ...t, ...d.$attrs }), {
        default: v(() => [
          y(d.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]),
      a(l).isSelected.value && a(e).valueElement.value && !a(e).valueElementHasChildren.value ? (h(), b(Ge, {
        key: 0,
        to: a(e).valueElement.value
      }, [
        y(d.$slots, "default")
      ], 8, ["to"])) : G("", !0)
    ], 64));
  }
}), Bc = /* @__PURE__ */ g({
  __name: "SelectViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ae(tt), n = e.position === "item-aligned" ? Xo() : void 0, { primitiveElement: s, currentElement: l } = F();
    q(() => {
      e == null || e.onViewportChange(l.value);
    });
    const i = $(0);
    function r(u) {
      const d = u.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: c } = n ?? {};
      if (p != null && p.value && (c != null && c.value)) {
        const f = Math.abs(i.value - d.scrollTop);
        if (f > 0) {
          const m = window.innerHeight - Ce * 2, C = Number.parseFloat(
            c.value.style.minHeight
          ), w = Number.parseFloat(c.value.style.height), P = Math.max(C, w);
          if (P < m) {
            const _ = P + f, E = Math.min(m, _), x = _ - E;
            c.value.style.height = `${E}px`, c.value.style.bottom === "0px" && (d.scrollTop = x > 0 ? x : 0, c.value.style.justifyContent = "flex-end");
          }
        }
      }
      i.value = d.scrollTop;
    }
    return (u, d) => (h(), Z(ie, null, [
      M(a(D), T({
        ref_key: "primitiveElement",
        ref: s,
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...u.$attrs, ...t }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        onScroll: r
      }), {
        default: v(() => [
          y(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      M(a(D), { as: "style" }, {
        default: v(() => [
          ue(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      })
    ], 64));
  }
}), sa = /* @__PURE__ */ g({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(o, { emit: t }) {
    const e = t, { injectCollection: n } = re(), s = n(), l = Ae(tt), i = $(null);
    function r() {
      i.value !== null && (window.clearInterval(i.value), i.value = null);
    }
    Q(() => {
      const p = s.value.find(
        (c) => c === document.activeElement
      );
      p == null || p.scrollIntoView({ block: "nearest" });
    });
    function u() {
      i.value === null && (i.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    function d() {
      var p;
      (p = l.onItemLeave) == null || p.call(l), i.value === null && (i.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    return uo(() => r()), (p, c) => {
      var f;
      return h(), b(a(D), T({
        "aria-hidden": "",
        style: {
          flexShrink: 0
        }
      }, (f = p.$parent) == null ? void 0 : f.$props, {
        onPointerdown: u,
        onPointermove: d,
        onPointerleave: c[0] || (c[0] = () => {
          r();
        })
      }), {
        default: v(() => [
          y(p.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), Sc = /* @__PURE__ */ g({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = Ae(tt), e = t.position === "item-aligned" ? Xo() : void 0, { primitiveElement: n, currentElement: s } = F(), l = $(!1);
    return Q((i) => {
      var r, u;
      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          l.value = p.scrollTop > 0;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), i(() => p.removeEventListener("scroll", d));
      }
    }), X(s, () => {
      s.value && (e == null || e.onScrollButtonChange(s.value));
    }), (i, r) => l.value ? (h(), b(sa, {
      key: 0,
      ref_key: "primitiveElement",
      ref: n,
      onAutoScroll: r[0] || (r[0] = () => {
        const { viewport: u, selectedItem: d } = a(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 512)) : G("", !0);
  }
}), Tc = /* @__PURE__ */ g({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = Ae(tt), e = t.position === "item-aligned" ? Xo() : void 0, { primitiveElement: n, currentElement: s } = F(), l = $(!1);
    return Q((i) => {
      var r, u;
      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          const c = p.scrollHeight - p.clientHeight;
          l.value = Math.ceil(p.scrollTop) < c;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), i(() => p.removeEventListener("scroll", d));
      }
    }), X(s, () => {
      s.value && (e == null || e.onScrollButtonChange(s.value));
    }), (i, r) => l.value ? (h(), b(sa, {
      key: 0,
      ref_key: "primitiveElement",
      ref: n,
      onAutoScroll: r[0] || (r[0] = () => {
        const { viewport: u, selectedItem: d } = a(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 512)) : G("", !0);
  }
}), Dc = /* @__PURE__ */ g({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const { primitiveElement: t, currentElement: e } = F(), n = Ie(), s = Cn();
    return bn(() => {
      var i;
      const l = !!Dt((i = s == null ? void 0 : s.default) == null ? void 0 : i.call(s)).length;
      n.onValueElementHasChildrenChange(l);
    }), q(() => {
      n.valueElement = e;
    }), (l, i) => (h(), b(a(D), {
      ref_key: "primitiveElement",
      ref: t,
      as: l.as,
      "as-child": l.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: v(() => {
        var r;
        return [
          a(na)((r = a(n).modelValue) == null ? void 0 : r.value) ? (h(), Z(ie, { key: 0 }, [
            ue(Ke(l.placeholder), 1)
          ], 64)) : y(l.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Oc = /* @__PURE__ */ g({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    return (t, e) => (h(), b(a(D), {
      "aria-hidden": "",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: v(() => [
        y(t.$slots, "default", {}, () => [
          ue("")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), la = /* @__PURE__ */ g({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = ["horizontal", "vertical"];
    function n(r) {
      return e.includes(r);
    }
    const s = S(
      () => n(t.orientation) ? t.orientation : "horizontal"
    ), l = S(
      () => s.value === "vertical" ? t.orientation : void 0
    ), i = S(
      () => t.decorative ? { role: "none" } : { "aria-orientation": l.value, role: "separator" }
    );
    return (r, u) => (h(), b(a(D), T({
      as: r.as,
      "as-child": r.asChild,
      "data-orientation": s.value
    }, i.value), {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
}), Ic = /* @__PURE__ */ g({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(la, R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function ia(o, [t, e]) {
  return Math.min(e, Math.max(t, o));
}
function Qi(o = [], t, e) {
  const n = [...o];
  return n[e] = t, n.sort((s, l) => s - l);
}
function ra(o, t, e) {
  const l = 100 / (e - t) * (o - t);
  return ia(l, [0, 100]);
}
function er(o, t) {
  return t > 2 ? `Value ${o + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][o] : void 0;
}
function tr(o, t) {
  if (o.length === 1)
    return 0;
  const e = o.map((s) => Math.abs(s - t)), n = Math.min(...e);
  return e.indexOf(n);
}
function or(o, t, e) {
  const n = o / 2, l = Jo([0, 50], [0, n]);
  return (n - l(t) * e) * e;
}
function nr(o) {
  return o.slice(0, -1).map((t, e) => o[e + 1] - t);
}
function ar(o, t) {
  if (t > 0) {
    const e = nr(o);
    return Math.min(...e) >= t;
  }
  return !0;
}
function Jo(o, t) {
  return (e) => {
    if (o[0] === o[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (o[1] - o[0]);
    return t[0] + n * (e - o[0]);
  };
}
function sr(o) {
  return (String(o).split(".")[1] || "").length;
}
function lr(o, t) {
  const e = 10 ** t;
  return Math.round(o * e) / e;
}
const ua = ["PageUp", "PageDown"], da = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], ca = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, [pa, fa] = W(["SliderVertical", "SliderHorizontal"]), va = /* @__PURE__ */ g({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Nt();
    return (l, i) => (h(), b(a(D), T({ "data-slider-impl": "" }, e, {
      onKeydown: i[0] || (i[0] = (r) => {
        r.key === "Home" ? (n("homeKeyDown", r), r.preventDefault()) : r.key === "End" ? (n("endKeyDown", r), r.preventDefault()) : a(ua).concat(a(da)).includes(r.key) && (n("stepKeyDown", r), r.preventDefault());
      }),
      onPointerdown: i[1] || (i[1] = (r) => {
        const u = r.target;
        u.setPointerCapture(r.pointerId), r.preventDefault(), a(s).thumbElements.value.includes(u) ? u.focus() : n("slideStart", r);
      }),
      onPointermove: i[2] || (i[2] = (r) => {
        r.target.hasPointerCapture(r.pointerId) && n("slideMove", r);
      }),
      onPointerup: i[3] || (i[3] = (r) => {
        const u = r.target;
        u.hasPointerCapture(r.pointerId) && (u.releasePointerCapture(r.pointerId), n("slideEnd", r));
      })
    }), {
      default: v(() => [
        y(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ir = /* @__PURE__ */ g({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, { max: s, min: l, dir: i, inverted: r } = U(e), { primitiveElement: u, currentElement: d } = F(), p = $(), c = S(() => (i == null ? void 0 : i.value) === "ltr" && !r.value || (i == null ? void 0 : i.value) !== "ltr" && r.value);
    function f(m) {
      const C = p.value || d.value.getBoundingClientRect(), w = [0, C.width], P = c.value ? [l.value, s.value] : [s.value, l.value], _ = Jo(w, P);
      return p.value = C, _(m - C.left);
    }
    return fa({
      startEdge: c.value ? "left" : "right",
      endEdge: c.value ? "right" : "left",
      direction: c.value ? 1 : -1,
      size: "width"
    }), (m, C) => (h(), b(va, {
      ref_key: "primitiveElement",
      ref: u,
      dir: a(i),
      "data-orientation": "horizontal",
      style: ae({
        "--radix-slider-thumb-transform": "translateX(-50%)"
      }),
      onSlideStart: C[0] || (C[0] = (w) => {
        const P = f(w.clientX);
        n("slideStart", P);
      }),
      onSlideMove: C[1] || (C[1] = (w) => {
        const P = f(w.clientX);
        n("slideMove", P);
      }),
      onSlideEnd: C[2] || (C[2] = () => {
        p.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: C[3] || (C[3] = (w) => {
        const P = c.value ? "from-left" : "from-right", _ = a(ca)[P].includes(w.key);
        n("stepKeyDown", w, _ ? -1 : 1);
      }),
      onEndKeyDown: C[4] || (C[4] = (w) => n("endKeyDown", w)),
      onHomeKeyDown: C[5] || (C[5] = (w) => n("homeKeyDown", w))
    }, {
      default: v(() => [
        y(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), rr = /* @__PURE__ */ g({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, { max: s, min: l, inverted: i } = U(e), { primitiveElement: r, currentElement: u } = F(), d = $(), p = S(() => !i.value);
    function c(f) {
      const m = d.value || u.value.getBoundingClientRect(), C = [0, m.height], w = p.value ? [s.value, l.value] : [l.value, s.value], P = Jo(C, w);
      return d.value = m, P(f - m.top);
    }
    return fa({
      startEdge: p.value ? "bottom" : "top",
      endEdge: p.value ? "top" : "bottom",
      size: "height",
      direction: p.value ? 1 : -1
    }), (f, m) => (h(), b(va, {
      ref_key: "primitiveElement",
      ref: r,
      "data-orientation": "vertical",
      style: ae({
        "--radix-slider-thumb-transform": "translateY(50%)"
      }),
      onSlideStart: m[0] || (m[0] = (C) => {
        const w = c(C.clientY);
        n("slideStart", w);
      }),
      onSlideMove: m[1] || (m[1] = (C) => {
        const w = c(C.clientY);
        n("slideMove", w);
      }),
      onSlideEnd: m[2] || (m[2] = () => {
        d.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: m[3] || (m[3] = (C) => {
        const w = p.value ? "from-bottom" : "from-top", P = a(ca)[w].includes(C.key);
        n("stepKeyDown", C, P ? -1 : 1);
      }),
      onEndKeyDown: m[4] || (m[4] = (C) => n("endKeyDown", C)),
      onHomeKeyDown: m[5] || (m[5] = (C) => n("homeKeyDown", C))
    }, {
      default: v(() => [
        y(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), ur = ["value", "name", "disabled"], [Nt, dr] = W("SliderRoot"), Ac = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    name: {},
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: !1 },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(o, { emit: t }) {
    const e = o, n = t, { min: s, max: l, step: i, minStepsBetweenThumbs: r, orientation: u, disabled: d, dir: p } = U(e), c = de(p), { createCollection: f } = re("sliderThumb"), { primitiveElement: m, currentElement: C } = F();
    f(C);
    const w = Ne(C), P = J(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), _ = $(0), E = $(P.value);
    function x(k) {
      const N = tr(P.value, k);
      A(k, N);
    }
    function B(k) {
      A(k, _.value);
    }
    function I() {
      const k = E.value[_.value];
      P.value[_.value] !== k && n("valueCommit", P.value);
    }
    function A(k, N, { commit: O } = { commit: !1 }) {
      var ee;
      const H = sr(i.value), j = lr(Math.round((k - s.value) / i.value) * i.value + s.value, H), L = ia(j, [s.value, l.value]), z = Qi(P.value, L, N);
      if (ar(z, r.value * i.value)) {
        _.value = z.indexOf(L);
        const ne = String(z) !== String(P.value);
        ne && O && n("valueCommit", z), ne && ((ee = V.value[_.value]) == null || ee.focus(), P.value = z);
      }
    }
    const V = $([]);
    return dr({
      modelValue: P,
      valueIndexToChangeRef: _,
      thumbElements: V,
      orientation: u,
      min: s,
      max: l,
      disabled: d
    }), (k, N) => (h(), Z(ie, null, [
      (h(), b(_e(a(u) === "horizontal" ? ir : rr), T(k.$attrs, {
        ref_key: "primitiveElement",
        ref: m,
        "as-child": k.asChild,
        as: k.as,
        min: a(s),
        max: a(l),
        dir: a(c),
        inverted: k.inverted,
        "aria-disabled": a(d),
        "data-disabled": a(d),
        onPointerdown: N[0] || (N[0] = () => {
          a(d) || (E.value = a(P));
        }),
        onSlideStart: N[1] || (N[1] = (O) => !a(d) && x(O)),
        onSlideMove: N[2] || (N[2] = (O) => !a(d) && B(O)),
        onSlideEnd: N[3] || (N[3] = (O) => !a(d) && I),
        onHomeKeyDown: N[4] || (N[4] = (O) => !a(d) && A(a(s), 0, { commit: !0 })),
        onEndKeyDown: N[5] || (N[5] = (O) => !a(d) && A(a(l), a(P).length - 1, { commit: !0 })),
        onStepKeyDown: N[6] || (N[6] = (O, H) => {
          if (!a(d)) {
            const z = a(ua).includes(O.key) || O.shiftKey && a(da).includes(O.key) ? 10 : 1, ee = _.value, ne = a(P)[ee], Ue = a(i) * z * H;
            A(ne + Ue, ee, { commit: !0 });
          }
        })
      }), {
        default: v(() => [
          y(k.$slots, "default", { modelValue: a(P) })
        ]),
        _: 3
      }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"])),
      a(w) ? (h(!0), Z(ie, { key: 0 }, co(a(P), (O, H) => (h(), Z("input", {
        key: H,
        value: O,
        type: "number",
        style: { display: "none" },
        name: k.name ? k.name + (a(P).length > 1 ? "[]" : "") : void 0,
        disabled: a(d)
      }, null, 8, ur))), 128)) : G("", !0)
    ], 64));
  }
}), cr = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, n = Nt(), s = pa(), { primitiveElement: l, currentElement: i } = F(), r = S(() => {
      var C, w;
      return (w = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : w[e.index];
    }), u = S(() => r.value === void 0 ? 0 : ra(r.value, n.min.value ?? 0, n.max.value ?? 100)), d = S(() => {
      var C, w;
      return er(e.index, ((w = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : w.length) ?? 0);
    }), p = xn(i), c = S(() => p[s.size].value), f = S(() => c.value ? or(c.value, u.value, s.direction) : 0), m = Tt();
    return q(() => {
      n.thumbElements.value.push(i.value);
    }), fe(() => {
      const C = n.thumbElements.value.findIndex((w) => w === i.value) ?? -1;
      n.thumbElements.value.splice(C, 1);
    }), t({
      $el: i
    }), (C, w) => (h(), b(a(D), T(C.$attrs, {
      ref_key: "primitiveElement",
      ref: l,
      role: "slider",
      "data-radix-vue-collection-item": "",
      tabindex: a(n).disabled.value ? void 0 : 0,
      "aria-label": C.$attrs["aria-label"] || d.value,
      "data-disabled": a(n).disabled.value,
      "data-orientation": a(n).orientation.value,
      "aria-valuenow": r.value,
      "aria-valuemin": a(n).min.value,
      "aria-valuemax": a(n).max.value,
      "aria-orientation": a(n).orientation.value,
      "as-child": C.asChild,
      as: C.as,
      style: {
        transform: "var(--radix-slider-thumb-transform)",
        position: "absolute",
        [a(s).startEdge]: `calc(${u.value}% + ${f.value}px)`,
        /**
         * There will be no value on initial render while we work out the index so we hide thumbs
         * without a value, otherwise SSR will render them in the wrong position before they
         * snap into the correct position during hydration which would be visually jarring for
         * slower connections.
         */
        display: !a(m) && r.value === void 0 ? "none" : void 0
      },
      onFocus: w[0] || (w[0] = () => {
        a(n).valueIndexToChangeRef.value = C.index;
      })
    }), {
      default: v(() => [
        y(C.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"]));
  }
}), Mc = /* @__PURE__ */ g({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { injectCollection: e } = re("sliderThumb"), n = e(), { primitiveElement: s, currentElement: l } = F(), i = S(() => l.value ? n.value.findIndex((r) => r === l.value) : -1);
    return (r, u) => (h(), b(cr, T({
      ref_key: "primitiveElement",
      ref: s
    }, t, { index: i.value }), {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
}), kc = /* @__PURE__ */ g({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Nt();
    return (n, s) => (h(), b(a(D), {
      "as-child": t.asChild,
      as: n.as,
      "data-disabled": a(e).disabled.value,
      "data-orientation": a(e).orientation.value
    }, {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "data-disabled", "data-orientation"]));
  }
}), Rc = /* @__PURE__ */ g({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Nt(), e = pa(), n = S(() => {
      var i, r;
      return (r = (i = t.modelValue) == null ? void 0 : i.value) == null ? void 0 : r.map(
        (u) => ra(u, t.min.value, t.max.value)
      );
    }), s = S(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), l = S(() => 100 - Math.max(...n.value));
    return (i, r) => (h(), b(a(D), {
      "data-disabled": a(t).disabled.value,
      "data-orientation": a(t).orientation.value,
      "as-child": i.asChild,
      as: i.as,
      style: ae({
        [a(e).startEdge]: `${s.value}%`,
        [a(e).endEdge]: `${l.value}%`
      })
    }, {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]));
  }
}), pr = ["name", "disabled", "required", "value", "checked", "data-state", "data-disabled"], [fr, vr] = W("SwitchRoot"), Vc = /* @__PURE__ */ g({
  __name: "SwitchRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = U(e), l = J(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    });
    function i() {
      s.value || (l.value = !l.value);
    }
    const { primitiveElement: r, currentElement: u } = F(), d = Ne(u), p = S(() => {
      var c;
      return e.id && u.value ? (c = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : c.innerText : void 0;
    });
    return vr({
      checked: l,
      toggleCheck: i,
      disabled: s
    }), (c, f) => (h(), Z(ie, null, [
      M(a(D), T(c.$attrs, {
        id: c.id,
        ref_key: "primitiveElement",
        ref: r,
        role: "switch",
        type: c.as === "button" ? "button" : void 0,
        value: c.value,
        "aria-label": c.$attrs["aria-label"] || p.value,
        "aria-checked": a(l),
        "aria-required": c.required,
        "data-state": a(l) ? "checked" : "unchecked",
        "data-disabled": a(s) ? "" : void 0,
        "as-child": c.asChild,
        as: c.as,
        disabled: a(s),
        onClick: i,
        onKeydown: le(oe(i, ["prevent"]), ["enter"])
      }), {
        default: v(() => [
          y(c.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]),
      a(d) ? (h(), Z("input", {
        key: 0,
        type: "checkbox",
        name: c.name,
        tabindex: "-1",
        "aria-hidden": "",
        disabled: a(s),
        required: c.required,
        value: c.value,
        checked: !!a(l),
        "data-state": a(l) ? "checked" : "unchecked",
        "data-disabled": a(s) ? "" : void 0,
        style: ae({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, pr)) : G("", !0)
    ], 64));
  }
}), Fc = /* @__PURE__ */ g({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = fr();
    return (e, n) => {
      var s;
      return h(), b(a(D), {
        "data-state": (s = a(t).checked) != null && s.value ? "checked" : "unchecked",
        "data-disabled": a(t).disabled.value ? "" : void 0,
        "as-child": e.asChild,
        as: e.as
      }, {
        default: v(() => [
          y(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
}), [Ht, mr] = W("TabsRoot"), Lc = /* @__PURE__ */ g({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { orientation: s, dir: l } = U(e), i = de(l), r = J(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), u = $();
    return mr({
      modelValue: r,
      changeModelValue: (d) => {
        r.value = d;
      },
      orientation: s,
      dir: i,
      activationMode: e.activationMode,
      baseId: te(),
      tabsList: u
    }), (d, p) => (h(), b(a(D), {
      dir: a(i),
      "data-orientation": a(s),
      "as-child": d.asChild,
      as: d.as
    }, {
      default: v(() => [
        y(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), Kc = /* @__PURE__ */ g({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { loop: e } = U(t), n = Ht();
    return (s, l) => (h(), b(a(Ze), {
      "as-child": "",
      orientation: a(n).orientation.value,
      dir: a(n).dir.value,
      loop: a(e)
    }, {
      default: v(() => [
        M(a(D), {
          ref: (i) => {
            i && "$el" in i && (a(n).tabsList.value = i.$el);
          },
          role: "tablist",
          "as-child": s.asChild,
          as: s.as,
          "aria-orientation": a(n).orientation.value
        }, {
          default: v(() => [
            y(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function ma(o, t) {
  return `${o}-trigger-${t}`;
}
function ha(o, t) {
  return `${o}-content-${t}`;
}
const Nc = /* @__PURE__ */ g({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ht(), n = S(() => ma(e.baseId, t.value)), s = S(() => ha(e.baseId, t.value)), l = S(() => t.value === e.modelValue.value), i = $(l.value);
    return q(() => {
      requestAnimationFrame(() => {
        i.value = !1;
      });
    }), (r, u) => (h(), b(a(se), {
      present: l.value,
      "force-mount": ""
    }, {
      default: v(({ present: d }) => [
        M(a(D), {
          id: s.value,
          "as-child": r.asChild,
          as: r.as,
          role: "tabpanel",
          "data-state": l.value ? "active" : "inactive",
          "data-orientation": a(e).orientation.value,
          "aria-labelledby": n.value,
          hidden: !d.value,
          tabindex: "0",
          style: ae({
            animationDuration: i.value ? "0s" : void 0
          })
        }, {
          default: v(() => [
            r.forceMount || l.value ? y(r.$slots, "default", { key: 0 }) : G("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Hc = /* @__PURE__ */ g({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Ht(), n = S(() => ma(e.baseId, t.value)), s = S(() => ha(e.baseId, t.value)), l = S(() => t.value === e.modelValue.value);
    return (i, r) => (h(), b(a(Qe), {
      "as-child": "",
      focusable: !i.disabled,
      active: l.value
    }, {
      default: v(() => [
        M(a(D), {
          id: n.value,
          role: "tab",
          type: i.as === "button" ? "button" : void 0,
          as: i.as,
          "as-child": i.asChild,
          "aria-selected": l.value ? "true" : "false",
          "aria-controls": s.value,
          "data-state": l.value ? "active" : "inactive",
          disabled: i.disabled,
          "data-disabled": i.disabled ? "" : void 0,
          "data-orientation": a(e).orientation.value,
          onMousedown: r[0] || (r[0] = oe((u) => {
            !i.disabled && u.ctrlKey === !1 ? a(e).changeModelValue(i.value) : u.preventDefault();
          }, ["left"])),
          onKeydown: r[1] || (r[1] = le((u) => a(e).changeModelValue(i.value), ["enter", "space"])),
          onFocus: r[2] || (r[2] = () => {
            const u = a(e).activationMode !== "manual";
            !l.value && !i.disabled && u && a(e).changeModelValue(i.value);
          })
        }, {
          default: v(() => [
            y(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), Wc = /* @__PURE__ */ g({
  __name: "TabsIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ht(), n = $({
      size: null,
      position: null
    });
    return X(() => e.modelValue.value, async (s) => {
      var i;
      await Y();
      const l = (i = e.tabsList.value) == null ? void 0 : i.querySelector('[role="tab"][data-state="active"]');
      l && (e.orientation.value === "horizontal" ? n.value = {
        size: l.offsetWidth,
        position: l.offsetLeft
      } : n.value = {
        size: l.offsetHeight,
        position: l.offsetTop
      });
    }, { immediate: !0 }), (s, l) => typeof n.value.size == "number" ? (h(), b(a(D), T({ key: 0 }, t, {
      style: {
        "--radix-tabs-indicator-size": `${n.value.size}px`,
        "--radix-tabs-indicator-position": `${n.value.position}px`
      }
    }), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"])) : G("", !0);
  }
}), [Wt, hr] = W("TagsInputRoot"), jc = /* @__PURE__ */ g({
  __name: "TagsInputRoot",
  props: {
    modelValue: {},
    defaultValue: { default: () => [] },
    addOnPaste: { type: Boolean },
    duplicate: { type: Boolean },
    disabled: { type: Boolean },
    delimiter: { default: "," },
    dir: {},
    max: { default: 0 },
    required: { type: Boolean },
    name: {},
    id: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "invalid"],
  setup(o, { emit: t }) {
    const e = o, n = t, { addOnPaste: s, disabled: l, delimiter: i, max: r, id: u, dir: d } = U(e), p = de(d), c = J(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: !0,
      deep: !0
    }), { primitiveElement: f, currentElement: m } = F(), { focused: C } = is(m), w = Ne(m), { getItems: P } = Vn(), _ = $(), E = $(!1);
    return hr({
      modelValue: c,
      onAddValue: (x) => {
        if (c.value.length >= r.value && r.value)
          return n("invalid", x), !1;
        if (e.duplicate)
          return c.value.push(x), !0;
        if (c.value.includes(x))
          E.value = !0;
        else
          return c.value.push(x), !0;
        return n("invalid", x), !1;
      },
      onRemoveValue: (x) => {
        x !== -1 && c.value.splice(x, 1);
      },
      onInputKeydown: (x) => {
        const B = x.target, I = P().map((V) => V.ref).filter((V) => V.dataset.disabled !== "");
        if (!I.length)
          return;
        const A = I.at(-1);
        switch (x.key) {
          case "Delete":
          case "Backspace": {
            if (B.selectionStart !== 0 || B.selectionEnd !== 0)
              break;
            if (_.value) {
              const V = I.findIndex((k) => k === _.value);
              c.value.splice(V, 1), _.value = _.value === A ? I.at(V - 1) : I.at(V + 1), x.preventDefault();
            } else
              x.key === "Backspace" && (_.value = A, x.preventDefault());
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const V = x.key === "ArrowRight" && p.value === "ltr" || x.key === "ArrowLeft" && p.value === "rtl", k = !V;
            if (B.selectionStart !== 0 || B.selectionEnd !== 0)
              break;
            if (k && !_.value)
              _.value = A, x.preventDefault();
            else if (V && A && _.value === A)
              _.value = void 0, x.preventDefault();
            else if (_.value) {
              const N = Ye(x, _.value, void 0, {
                itemsArray: I,
                loop: !1,
                dir: p.value
              });
              N && (_.value = N), x.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            _.value && x.preventDefault();
            break;
          }
          default:
            _.value = void 0;
        }
      },
      selectedElement: _,
      isInvalidInput: E,
      addOnPaste: s,
      dir: p,
      disabled: l,
      delimiter: i,
      max: r,
      id: u
    }), (x, B) => (h(), b(a(Fn), null, {
      default: v(() => [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: f,
          dir: a(p),
          as: x.as,
          "as-child": x.asChild,
          "data-invalid": E.value ? "" : void 0,
          "data-disabled": a(l) ? "" : void 0,
          "data-focused": a(C) ? "" : void 0
        }, {
          default: v(() => [
            y(x.$slots, "default", { values: a(c) }),
            a(w) && x.name ? (h(), b(a(Rn), {
              key: 0,
              name: x.name,
              value: a(c),
              required: x.required,
              disabled: a(l)
            }, null, 8, ["name", "value", "required", "disabled"])) : G("", !0)
          ]),
          _: 3
        }, 8, ["dir", "as", "as-child", "data-invalid", "data-disabled", "data-focused"])
      ]),
      _: 3
    }));
  }
}), zc = /* @__PURE__ */ g({
  __name: "TagsInputInput",
  props: {
    placeholder: {},
    autoFocus: { type: Boolean },
    maxLength: {},
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(o) {
    const t = o, e = Wt(), { primitiveElement: n, currentElement: s } = F();
    async function l(u) {
      if (await Y(), u.defaultPrevented)
        return;
      const d = u.target;
      if (!d.value)
        return;
      e.onAddValue(d.value) && (d.value = ""), u.preventDefault();
    }
    function i(u) {
      e.isInvalidInput.value = !1;
      const d = e.delimiter.value;
      if (d === u.data) {
        const p = u.target;
        p.value = p.value.replaceAll(d, ""), e.onAddValue(p.value) && (p.value = "");
      }
    }
    function r(u) {
      if (e.addOnPaste.value) {
        u.preventDefault();
        const d = u.clipboardData;
        if (!d)
          return;
        const p = d.getData("text");
        e.delimiter.value ? p.split(e.delimiter.value).forEach((f) => {
          e.onAddValue(f);
        }) : e.onAddValue(p);
      }
    }
    return q(() => {
      const u = s.value.nodeName === "INPUT" ? s.value : s.value.querySelector("input");
      u && setTimeout(() => {
        t.autoFocus && (u == null || u.focus());
      }, 1);
    }), (u, d) => {
      var p;
      return h(), b(a(D), T(t, {
        id: (p = a(e).id) == null ? void 0 : p.value,
        ref_key: "primitiveElement",
        ref: n,
        type: "text",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        maxlength: u.maxLength,
        disabled: a(e).disabled.value,
        "data-invalid": a(e).isInvalidInput.value ? "" : void 0,
        onInput: i,
        onKeydown: [
          le(l, ["enter"]),
          a(e).onInputKeydown
        ],
        onPaste: r
      }), {
        default: v(() => [
          y(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "maxlength", "disabled", "data-invalid", "onKeydown"]);
    };
  }
}), [ya, yr] = W("TagsInputItem"), Uc = /* @__PURE__ */ g({
  __name: "TagsInputItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { value: e } = U(t), n = Wt(), { primitiveElement: s, currentElement: l } = F(), i = S(() => n.selectedElement.value === l.value), r = te(), u = S(() => t.disabled || n.disabled.value);
    return yr({
      value: e,
      isSelected: i,
      disabled: u,
      textId: r
    }), (d, p) => (h(), b(a(Ln), null, {
      default: v(() => [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: s,
          as: d.as,
          "as-child": d.asChild,
          "aria-labelledby": a(r),
          "aria-current": i.value,
          "data-disabled": u.value ? "" : void 0,
          "data-state": i.value ? "active" : "inactive"
        }, {
          default: v(() => [
            y(d.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "aria-labelledby", "aria-current", "data-disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), qc = /* @__PURE__ */ g({
  __name: "TagsInputItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = ya();
    return (n, s) => (h(), b(a(D), T(t, {
      id: a(e).textId
    }), {
      default: v(() => [
        y(n.$slots, "default", {}, () => [
          ue(Ke(a(e).value.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Gc = /* @__PURE__ */ g({
  __name: "TagsInputItemDelete",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Wt(), n = ya(), s = S(() => {
      var i;
      return ((i = n.disabled) == null ? void 0 : i.value) || e.disabled.value;
    });
    function l() {
      if (s.value)
        return;
      const i = e.modelValue.value.findIndex((r) => r === n.value.value);
      e.onRemoveValue(i);
    }
    return (i, r) => (h(), b(a(D), T({ tabindex: "-1" }, t, {
      "aria-labelledby": a(n).textId,
      "aria-current": a(n).isSelected.value,
      "data-state": a(n).isSelected.value ? "active" : "inactive",
      "data-disabled": s.value ? "" : void 0,
      type: i.as === "button" ? "button" : void 0,
      onClick: l
    }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby", "aria-current", "data-state", "data-disabled", "type"]));
  }
}), Yc = /* @__PURE__ */ g({
  __name: "TagsInputClear",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Wt();
    function n() {
      e.disabled.value || (e.modelValue.value = []);
    }
    return (s, l) => (h(), b(a(D), T(t, {
      type: s.as === "button" ? "button" : void 0,
      "data-disabled": a(e).disabled.value ? "" : void 0,
      onClick: n
    }), {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "data-disabled"]));
  }
}), [jt, gr] = W("ToastProvider"), Xc = /* @__PURE__ */ g({
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(o) {
    const t = o, { label: e, duration: n, swipeDirection: s, swipeThreshold: l } = U(t), i = $(), r = $(0), u = $(!1), d = $(!1);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const p = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(p);
    }
    return gr({
      label: e,
      duration: n,
      swipeDirection: s,
      swipeThreshold: l,
      toastCount: r,
      viewport: i,
      onViewportChange(p) {
        i.value = p;
      },
      onToastAdd() {
        r.value++;
      },
      onToastRemove() {
        r.value--;
      },
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: d
    }), (p, c) => y(p.$slots, "default");
  }
}), br = "toast.swipeStart", Cr = "toast.swipeMove", _r = "toast.swipeCancel", wr = "toast.swipeEnd", Er = ["F8"], lo = "toast.viewportPause", io = "toast.viewportResume";
function Et(o, t, e) {
  const n = e.originalEvent.currentTarget, s = new CustomEvent(o, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && n.addEventListener(o, t, { once: !0 }), n.dispatchEvent(s);
}
function dn(o, t, e = 0) {
  const n = Math.abs(o.x), s = Math.abs(o.y), l = n > s;
  return t === "left" || t === "right" ? l && n > e : !l && s > e;
}
function xr(o) {
  return o.nodeType === o.ELEMENT_NODE;
}
function ga(o) {
  const t = [];
  return Array.from(o.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), xr(n)) {
      const s = n.ariaHidden || n.hidden || n.style.display === "none", l = n.dataset.radixToastAnnounceExclude === "";
      if (!s)
        if (l) {
          const i = n.dataset.radixToastAnnounceAlt;
          i && t.push(i);
        } else
          t.push(...ga(n));
    }
  }), t;
}
const $r = /* @__PURE__ */ g({
  __name: "ToastAnnounce",
  setup(o) {
    const t = jt(), e = es(1e3), n = $(!1);
    return ss(() => {
      n.value = !0;
    }), (s, l) => a(e) || n.value ? (h(), b(a(Je), { key: 0 }, {
      default: v(() => [
        ue(Ke(a(t).label.value) + " ", 1),
        y(s.$slots, "default")
      ]),
      _: 3
    })) : G("", !0);
  }
}), [Pr, Br] = W("ToastRoot"), Sr = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = be(), { primitiveElement: l, currentElement: i } = F(), r = jt(), u = $(null), d = $(null), p = S(() => e.duration || r.duration.value), c = $(0), f = $(p.value), m = $(0);
    function C(_) {
      !_ || _ === Number.POSITIVE_INFINITY || (window.clearTimeout(m.value), c.value = (/* @__PURE__ */ new Date()).getTime(), m.value = window.setTimeout(w, _));
    }
    function w() {
      var E, x;
      ((E = i.value) == null ? void 0 : E.contains(document.activeElement)) && ((x = r.viewport.value) == null || x.focus()), n("close");
    }
    const P = S(() => i.value ? ga(i.value) : null);
    if (e.type && !["foreground", "background"].includes(e.type)) {
      const _ = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(_);
    }
    return Q((_) => {
      const E = r.viewport.value;
      if (E) {
        const x = () => {
          C(f.value), n("resume");
        }, B = () => {
          const I = (/* @__PURE__ */ new Date()).getTime() - c.value;
          f.value = f.value - I, window.clearTimeout(m.value), n("pause");
        };
        return E.addEventListener(lo, B), E.addEventListener(io, x), () => {
          E.removeEventListener(lo, B), E.removeEventListener(io, x);
        };
      }
    }), Q(() => {
      e.open && !r.isClosePausedRef.value && C(p.value);
    }), go("Escape", (_) => {
      n("escapeKeyDown", _), _.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, w());
    }), q(() => {
      r.onToastAdd();
    }), fe(() => {
      r.onToastRemove();
    }), Br({ onClose: w }), (_, E) => (h(), Z(ie, null, [
      P.value ? (h(), b($r, {
        key: 0,
        role: "status",
        "aria-live": _.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": ""
      }, {
        default: v(() => [
          ue(Ke(P.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : G("", !0),
      (h(), b(Ge, {
        to: a(r).viewport.value
      }, [
        M(a(D), T({
          ref: (x) => {
            a(s)(x), l.value = x;
          },
          role: "status",
          "aria-live": "off",
          "aria-atomic": "",
          tabindex: "0",
          "data-radix-vue-collection-item": ""
        }, _.$attrs, {
          as: _.as,
          "as-child": _.asChild,
          "data-state": _.open ? "open" : "closed",
          "data-swipe-direction": a(r).swipeDirection.value,
          style: { userSelect: "none", touchAction: "none" },
          onPointerdown: E[0] || (E[0] = oe((x) => {
            u.value = { x: x.clientX, y: x.clientY };
          }, ["left"])),
          onPointermove: E[1] || (E[1] = (x) => {
            if (!u.value)
              return;
            const B = x.clientX - u.value.x, I = x.clientY - u.value.y, A = !!d.value, V = ["left", "right"].includes(a(r).swipeDirection.value), k = ["left", "up"].includes(a(r).swipeDirection.value) ? Math.min : Math.max, N = V ? k(0, B) : 0, O = V ? 0 : k(0, I), H = x.pointerType === "touch" ? 10 : 2, j = { x: N, y: O }, L = { originalEvent: x, delta: j };
            A ? (d.value = j, a(Et)(a(Cr), (z) => n("swipeMove", z), L)) : a(dn)(j, a(r).swipeDirection.value, H) ? (d.value = j, a(Et)(a(br), (z) => n("swipeStart", z), L), x.target.setPointerCapture(x.pointerId)) : (Math.abs(B) > H || Math.abs(I) > H) && (u.value = null);
          }),
          onPointerup: E[2] || (E[2] = (x) => {
            const B = d.value, I = x.target;
            if (I.hasPointerCapture(x.pointerId) && I.releasePointerCapture(x.pointerId), d.value = null, u.value = null, B) {
              const A = x.currentTarget, V = { originalEvent: x, delta: B };
              a(dn)(B, a(r).swipeDirection.value, a(r).swipeThreshold.value) ? a(Et)(a(wr), (k) => n("swipeEnd", k), V) : a(Et)(a(_r), (k) => n("swipeCancel", k), V), A == null || A.addEventListener("click", (k) => k.preventDefault(), {
                once: !0
              });
            }
          })
        }), {
          default: v(() => [
            y(_.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
      ], 8, ["to"]))
    ], 64));
  }
}), Jc = /* @__PURE__ */ g({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: !0 },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (l, i) => (h(), b(a(se), {
      present: l.forceMount || a(s)
    }, {
      default: v(() => [
        M(Sr, T({
          open: a(s),
          type: l.type,
          as: l.as,
          "as-child": l.asChild,
          duration: l.duration
        }, l.$attrs, {
          onClose: i[0] || (i[0] = (r) => s.value = !1),
          onPause: i[1] || (i[1] = (r) => n("pause")),
          onResume: i[2] || (i[2] = (r) => n("resume")),
          onEscapeKeyDown: i[3] || (i[3] = (r) => n("escapeKeyDown", r)),
          onSwipeStart: i[4] || (i[4] = (r) => {
            n("swipeStart", r), r.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: i[5] || (i[5] = (r) => {
            const { x: u, y: d } = r.detail.delta, p = r.currentTarget;
            p.setAttribute("data-swipe", "move"), p.style.setProperty("--radix-toast-swipe-move-x", `${u}px`), p.style.setProperty("--radix-toast-swipe-move-y", `${d}px`);
          }),
          onSwipeCancel: i[6] || (i[6] = (r) => {
            const u = r.currentTarget;
            u.setAttribute("data-swipe", "cancel"), u.style.removeProperty("--radix-toast-swipe-move-x"), u.style.removeProperty("--radix-toast-swipe-move-y"), u.style.removeProperty("--radix-toast-swipe-end-x"), u.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: i[7] || (i[7] = (r) => {
            const { x: u, y: d } = r.detail.delta, p = r.currentTarget;
            p.setAttribute("data-swipe", "end"), p.style.removeProperty("--radix-toast-swipe-move-x"), p.style.removeProperty("--radix-toast-swipe-move-y"), p.style.setProperty("--radix-toast-swipe-end-x", `${u}px`), p.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), s.value = !1;
          })
        }), {
          default: v(() => [
            y(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), ba = /* @__PURE__ */ g({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    return (t, e) => (h(), b(a(D), {
      as: t.as,
      "as-child": t.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": t.altText || void 0
    }, {
      default: v(() => [
        y(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
}), Tr = /* @__PURE__ */ g({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Pr();
    return (n, s) => (h(), b(ba, { "as-child": "" }, {
      default: v(() => [
        M(a(D), T(t, {
          type: n.as === "button" ? "button" : void 0,
          onClick: s[0] || (s[0] = (l) => a(e).onClose())
        }), {
          default: v(() => [
            y(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
}), Zc = /* @__PURE__ */ g({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    if (!o.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    return (e, n) => e.altText ? (h(), b(ba, {
      key: 0,
      "alt-text": e.altText,
      "as-child": ""
    }, {
      default: v(() => [
        M(Tr, {
          as: e.as,
          "as-child": e.asChild
        }, {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["alt-text"])) : G("", !0);
  }
}), cn = /* @__PURE__ */ g({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(o, { emit: t }) {
    const e = t, n = jt();
    return (s, l) => (h(), b(a(Je), {
      "aria-hidden": "",
      tabindex: "0",
      style: { position: "'fixed'" },
      onFocus: l[0] || (l[0] = (i) => {
        var d;
        const r = i.relatedTarget;
        !((d = a(n).viewport.value) != null && d.contains(r)) && e("focusFromOutsideViewport");
      })
    }, {
      default: v(() => [
        y(s.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Qc = /* @__PURE__ */ g({
  inheritAttrs: !1,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => Er },
    label: { default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(o) {
    const t = o, { hotkey: e, label: n } = U(t), { primitiveElement: s, currentElement: l } = F(), { createCollection: i } = re(), r = i(l), u = jt(), d = S(() => u.toastCount.value > 0), p = $(), c = $();
    go(e.value, () => {
      l.value.focus();
    }), q(() => {
      u.onViewportChange(l.value);
    }), Q((m) => {
      const C = l.value;
      if (d.value && C) {
        const w = () => {
          if (!u.isClosePausedRef.value) {
            const B = new CustomEvent(lo);
            C.dispatchEvent(B), u.isClosePausedRef.value = !0;
          }
        }, P = () => {
          if (u.isClosePausedRef.value) {
            const B = new CustomEvent(io);
            C.dispatchEvent(B), u.isClosePausedRef.value = !1;
          }
        }, _ = (B) => {
          !C.contains(B.relatedTarget) && P();
        }, E = () => {
          C.contains(document.activeElement) || P();
        }, x = (B) => {
          var V, k, N;
          const I = B.altKey || B.ctrlKey || B.metaKey;
          if (B.key === "Tab" && !I) {
            const O = document.activeElement, H = B.shiftKey;
            if (B.target === C && H) {
              (V = p.value) == null || V.focus();
              return;
            }
            const z = f({ tabbingDirection: H ? "backwards" : "forwards" }), ee = z.findIndex((ne) => ne === O);
            xt(z.slice(ee + 1)) ? B.preventDefault() : H ? (k = p.value) == null || k.focus() : (N = c.value) == null || N.focus();
          }
        };
        C.addEventListener("focusin", w), C.addEventListener("focusout", _), C.addEventListener("pointermove", w), C.addEventListener("pointerleave", E), C.addEventListener("keydown", x), window.addEventListener("blur", w), window.addEventListener("focus", P), m(() => {
          C.removeEventListener("focusin", w), C.removeEventListener("focusout", _), C.removeEventListener("pointermove", w), C.removeEventListener("pointerleave", E), C.removeEventListener("keydown", x), window.removeEventListener("blur", w), window.removeEventListener("focus", P);
        });
      }
    });
    function f({ tabbingDirection: m }) {
      const w = r.value.map((P) => {
        const _ = [P, ...xo(P)];
        return m === "forwards" ? _ : _.reverse();
      });
      return (m === "forwards" ? w.reverse() : w).flat();
    }
    return (m, C) => (h(), b(a(Vs), {
      role: "region",
      "aria-label": a(n).replace("{hotkey}", a(e).join("+").replace(/Key/g, "").replace(/Digit/g, "")),
      tabindex: "-1",
      style: ae({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: d.value ? void 0 : "none"
      })
    }, {
      default: v(() => [
        d.value ? (h(), b(cn, {
          key: 0,
          ref: (w) => {
            p.value = a(ve)(w);
          },
          onFocusFromOutsideViewport: C[0] || (C[0] = () => {
            const w = f({
              tabbingDirection: "forwards"
            });
            a(xt)(w);
          })
        }, null, 512)) : G("", !0),
        M(a(D), T({
          ref_key: "primitiveElement",
          ref: s,
          tabindex: "-1",
          as: m.as,
          "as-child": m.asChild
        }, m.$attrs), {
          default: v(() => [
            y(m.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        d.value ? (h(), b(cn, {
          key: 1,
          ref: (w) => {
            c.value = a(ve)(w);
          },
          onFocusFromOutsideViewport: C[1] || (C[1] = () => {
            const w = f({
              tabbingDirection: "backwards"
            });
            a(xt)(w);
          })
        }, null, 512)) : G("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), ep = /* @__PURE__ */ g({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tp = /* @__PURE__ */ g({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(D), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dr = /* @__PURE__ */ g({
  __name: "ToggleRoot",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:pressed"],
  setup(o, { emit: t }) {
    const e = o, s = J(e, "pressed", t, {
      defaultValue: e.defaultValue,
      passive: e.pressed === void 0
    });
    function l() {
      s.value = !s.value;
    }
    const i = S(() => s.value ? "on" : "off");
    return (r, u) => (h(), b(a(D), {
      type: r.as === "button" ? "button" : void 0,
      "as-child": e.asChild,
      as: r.as,
      "aria-pressed": a(s),
      "data-state": i.value,
      "data-disabled": r.disabled ? "" : void 0,
      disabled: r.disabled,
      onClick: l,
      onKeydown: le(l, ["enter"])
    }, {
      default: v(() => [
        y(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]));
  }
}), [Or, Ir] = W("ToggleGroupRoot"), Ar = /* @__PURE__ */ g({
  __name: "ToggleGroupRoot",
  props: {
    type: { default: "single" },
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { loop: s, rovingFocus: l, disabled: i, dir: r } = U(e), u = de(r), { modelValue: d, changeModelValue: p } = Bn(e, n);
    return Ir({
      type: e.type,
      modelValue: d,
      changeModelValue: p,
      dir: u,
      orientation: e.orientation,
      loop: s,
      rovingFocus: l,
      disabled: i
    }), (c, f) => (h(), b(_e(a(l) ? a(Ze) : a(D)), {
      "as-child": "",
      orientation: a(l) ? c.orientation : void 0,
      dir: a(u),
      loop: a(l) ? a(s) : void 0
    }, {
      default: v(() => [
        M(a(D), {
          role: "group",
          "as-child": c.asChild,
          as: c.as
        }, {
          default: v(() => [
            y(c.$slots, "default", { modelValue: a(d) })
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Mr = /* @__PURE__ */ g({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Or(), n = S(() => {
      var l;
      return ((l = e.disabled) == null ? void 0 : l.value) || t.disabled;
    }), s = S(() => {
      var l;
      return (l = e.modelValue.value) == null ? void 0 : l.includes(t.value);
    });
    return (l, i) => (h(), b(_e(a(e).rovingFocus.value ? a(Qe) : a(D)), {
      "as-child": "",
      focusable: !n.value,
      active: s.value
    }, {
      default: v(() => {
        var r;
        return [
          M(a(Dr), T(t, {
            disabled: n.value,
            pressed: a(e).type === "single" ? a(e).modelValue.value === l.value : (r = a(e).modelValue.value) == null ? void 0 : r.includes(l.value),
            "onUpdate:pressed": i[0] || (i[0] = (u) => a(e).changeModelValue(l.value))
          }), {
            default: v(() => [
              y(l.$slots, "default")
            ]),
            _: 3
          }, 16, ["disabled", "pressed"])
        ];
      }),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [Ca, kr] = W("ToolbarRoot"), op = /* @__PURE__ */ g({
  __name: "ToolbarRoot",
  props: {
    orientation: { default: "horizontal" },
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { orientation: e, dir: n } = U(t), s = de(n);
    return kr({ orientation: e, dir: s }), (l, i) => (h(), b(a(Ze), {
      "as-child": "",
      orientation: a(e),
      dir: a(s),
      loop: l.loop
    }, {
      default: v(() => [
        M(a(D), {
          role: "toolbar",
          "aria-orientation": a(e),
          "as-child": l.asChild,
          as: l.as
        }, {
          default: v(() => [
            y(l.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-orientation", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Rr = /* @__PURE__ */ g({
  __name: "ToolbarButton",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Qe), {
      "as-child": "",
      focusable: !e.disabled
    }, {
      default: v(() => [
        M(a(D), T({
          type: e.as === "button" ? "button" : void 0
        }, t), {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }, 8, ["focusable"]));
  }
}), np = /* @__PURE__ */ g({
  __name: "ToolbarLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Qe), {
      "as-child": "",
      focusable: ""
    }, {
      default: v(() => [
        M(a(D), T(t, {
          onKeydown: n[0] || (n[0] = (s) => {
            var l;
            s.key === " " && ((l = s.currentTarget) == null || l.click());
          })
        }), {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), ap = /* @__PURE__ */ g({
  __name: "ToolbarToggleGroup",
  props: {
    type: {},
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Ca(), l = ce(n);
    return (i, r) => (h(), b(a(Ar), T({ ...e, ...a(l) }, {
      "data-orientation": a(s).orientation.value,
      dir: a(s).dir.value,
      "roving-focus": !1
    }), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-orientation", "dir"]));
  }
}), sp = /* @__PURE__ */ g({
  __name: "ToolbarToggleItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(Rr, { "as-child": "" }, {
      default: v(() => [
        M(a(Mr), R(K(t)), {
          default: v(() => [
            y(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), lp = /* @__PURE__ */ g({
  __name: "ToolbarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ca();
    return (n, s) => (h(), b(la, {
      orientation: a(e).orientation.value,
      "as-child": t.asChild,
      as: n.as
    }, {
      default: v(() => [
        y(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["orientation", "as-child", "as"]));
  }
}), _a = "tooltip.open";
function Vr(o, t) {
  const e = Math.abs(t.top - o.y), n = Math.abs(t.bottom - o.y), s = Math.abs(t.right - o.x), l = Math.abs(t.left - o.x);
  switch (Math.min(e, n, s, l)) {
    case l:
      return "left";
    case s:
      return "right";
    case e:
      return "top";
    case n:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function Fr(o, t, e = 5) {
  const n = [];
  switch (t) {
    case "top":
      n.push(
        { x: o.x - e, y: o.y + e },
        { x: o.x + e, y: o.y + e }
      );
      break;
    case "bottom":
      n.push(
        { x: o.x - e, y: o.y - e },
        { x: o.x + e, y: o.y - e }
      );
      break;
    case "left":
      n.push(
        { x: o.x + e, y: o.y - e },
        { x: o.x + e, y: o.y + e }
      );
      break;
    case "right":
      n.push(
        { x: o.x - e, y: o.y - e },
        { x: o.x - e, y: o.y + e }
      );
      break;
  }
  return n;
}
function Lr(o) {
  const { top: t, right: e, bottom: n, left: s } = o;
  return [
    { x: s, y: t },
    { x: e, y: t },
    { x: e, y: n },
    { x: s, y: n }
  ];
}
function Kr(o, t) {
  const { x: e, y: n } = o;
  let s = !1;
  for (let l = 0, i = t.length - 1; l < t.length; i = l++) {
    const r = t[l].x, u = t[l].y, d = t[i].x, p = t[i].y;
    u > n != p > n && e < (d - r) * (n - u) / (p - u) + r && (s = !s);
  }
  return s;
}
function Nr(o) {
  const t = o.slice();
  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), Hr(t);
}
function Hr(o) {
  if (o.length <= 1)
    return o.slice();
  const t = [];
  for (let n = 0; n < o.length; n++) {
    const s = o[n];
    for (; t.length >= 2; ) {
      const l = t[t.length - 1], i = t[t.length - 2];
      if ((l.x - i.x) * (s.y - i.y) >= (l.y - i.y) * (s.x - i.x))
        t.pop();
      else
        break;
    }
    t.push(s);
  }
  t.pop();
  const e = [];
  for (let n = o.length - 1; n >= 0; n--) {
    const s = o[n];
    for (; e.length >= 2; ) {
      const l = e[e.length - 1], i = e[e.length - 2];
      if ((l.x - i.x) * (s.y - i.y) >= (l.y - i.y) * (s.x - i.x))
        e.pop();
      else
        break;
    }
    e.push(s);
  }
  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);
}
const [Zo, Wr] = W("TooltipProvider"), ip = /* @__PURE__ */ g({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean }
  },
  setup(o) {
    const t = o, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: s, disableClosingTrigger: l } = U(t), i = $(!0), r = $(!1), { start: u, stop: d } = yo(() => {
      i.value = !0;
    }, n, { immediate: !1 });
    return Wr({
      isOpenDelayed: i,
      delayDuration: e,
      onOpen() {
        d(), i.value = !1;
      },
      onClose() {
        u();
      },
      isPointerInTransitRef: r,
      onPointerInTransitChange(p) {
        r.value = p;
      },
      disableHoverableContent: s,
      disableClosingTrigger: l
    }), (p, c) => y(p.$slots, "default");
  }
}), [zt, jr] = W("TooltipRoot"), rp = /* @__PURE__ */ g({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Zo(), l = S(() => e.disableHoverableContent ?? s.disableHoverableContent.value), i = S(() => e.disableClosingTrigger ?? s.disableClosingTrigger.value), r = S(() => e.delayDuration ?? s.delayDuration.value), u = J(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    X(u, (_) => {
      s.onClose && (_ ? (s.onOpen(), document.dispatchEvent(new CustomEvent(_a))) : s.onClose());
    });
    const d = $(!1), p = $(), c = S(() => u.value ? d.value ? "delayed-open" : "instant-open" : "closed"), { start: f, stop: m } = yo(() => {
      d.value = !0, u.value = !0;
    }, r, { immediate: !1 });
    function C() {
      m(), d.value = !1, u.value = !0;
    }
    function w() {
      m(), u.value = !1;
    }
    function P() {
      f();
    }
    return jr({
      contentId: te(),
      open: u,
      stateAttribute: c,
      trigger: p,
      onTriggerChange(_) {
        p.value = _;
      },
      onTriggerEnter() {
        s.isOpenDelayed.value ? P() : C();
      },
      onTriggerLeave() {
        l.value ? w() : m();
      },
      onOpen: C,
      onClose: w,
      disableHoverableContent: l,
      disableClosingTrigger: i
    }), (_, E) => (h(), b(a(He), null, {
      default: v(() => [
        y(_.$slots, "default")
      ]),
      _: 3
    }));
  }
}), up = /* @__PURE__ */ g({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = zt(), n = Zo(), { primitiveElement: s, currentElement: l } = F(), i = $(!1), r = $(!1);
    function u() {
      i.value = !1;
    }
    function d() {
      i.value = !0, document.addEventListener("pointerup", u, { once: !0 });
    }
    return q(() => {
      e.onTriggerChange(l.value);
    }), (p, c) => (h(), b(a(We), { "as-child": "" }, {
      default: v(() => [
        M(a(D), {
          ref_key: "primitiveElement",
          ref: s,
          "aria-describedby": a(e).open.value ? a(e).contentId : void 0,
          "data-state": a(e).stateAttribute.value,
          as: p.as,
          "as-child": t.asChild,
          onPointermove: c[0] || (c[0] = (f) => {
            f.pointerType !== "touch" && !r.value && !a(n).isPointerInTransitRef.value && (a(e).onTriggerEnter(), r.value = !0);
          }),
          onPointerleave: c[1] || (c[1] = (f) => {
            a(e).onTriggerLeave(), r.value = !1;
          }),
          onPointerdown: d,
          onFocus: c[2] || (c[2] = () => {
            i.value || a(e).onOpen();
          }),
          onBlur: c[3] || (c[3] = (f) => a(e).onClose()),
          onClick: c[4] || (c[4] = () => {
            a(e).disableClosingTrigger.value || a(e).onClose();
          })
        }, {
          default: v(() => [
            y(p.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), wa = /* @__PURE__ */ g({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean, default: !1 },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = $(), l = zt(), i = Cn(), r = S(() => {
      var p;
      return (p = i.default) == null ? void 0 : p.call(i);
    }), u = S(() => {
      var f;
      if (e.ariaLabel)
        return e.ariaLabel;
      let p = "";
      function c(m) {
        typeof m.children == "string" ? p += m.children : Array.isArray(m.children) && m.children.forEach((C) => c(C));
      }
      return (f = r.value) == null || f.forEach((m) => c(m)), p;
    }), d = S(() => {
      const { ariaLabel: p, ...c } = e;
      return c;
    });
    return q(() => {
      Se(window, "scroll", (p) => {
        const c = p.target;
        c != null && c.contains(l.trigger.value) && l.onClose();
      }), Se(window, _a, l.onClose);
    }), (p, c) => (h(), b(a(De), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: c[0] || (c[0] = (f) => n("escapeKeyDown", f)),
      onPointerDownOutside: c[1] || (c[1] = (f) => {
        var m;
        a(l).disableClosingTrigger.value && ((m = a(l).trigger.value) != null && m.contains(f.target)) && f.preventDefault(), n("pointerDownOutside", f);
      }),
      onFocusOutside: c[2] || (c[2] = oe(() => {
      }, ["prevent"])),
      onDismiss: c[3] || (c[3] = (f) => a(l).onClose())
    }, {
      default: v(() => [
        M(a(Fe), T({
          ref_key: "contentElement",
          ref: s,
          "data-state": a(l).stateAttribute.value
        }, { ...p.$attrs, ...d.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: v(() => [
            y(p.$slots, "default"),
            M(a(Je), {
              id: a(l).contentId,
              role: "tooltip"
            }, {
              default: v(() => [
                ue(Ke(u.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }));
  }
}), zr = /* @__PURE__ */ g({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = F(), { trigger: s, onClose: l } = zt(), i = Zo(), r = $(null);
    function u() {
      r.value = null, i.onPointerInTransitChange(!1);
    }
    function d(p, c) {
      const f = p.currentTarget, m = { x: p.clientX, y: p.clientY }, C = Vr(m, f.getBoundingClientRect()), w = Fr(m, C), P = Lr(c.getBoundingClientRect()), _ = Nr([...w, ...P]);
      r.value = _, i.onPointerInTransitChange(!0);
    }
    return Q((p) => {
      if (s.value && n.value) {
        const c = (m) => d(m, n.value), f = (m) => d(m, s.value);
        s.value.addEventListener("pointerleave", c), n.value.addEventListener("pointerleave", f), p(() => {
          var m, C;
          (m = s.value) == null || m.removeEventListener("pointerleave", c), (C = n.value) == null || C.removeEventListener("pointerleave", f);
        });
      }
    }), Q((p) => {
      if (r.value) {
        const c = (f) => {
          var _, E;
          if (!r.value)
            return;
          const m = f.target, C = { x: f.clientX, y: f.clientY }, w = ((_ = s.value) == null ? void 0 : _.contains(m)) || ((E = n.value) == null ? void 0 : E.contains(m)), P = !Kr(C, r.value);
          w ? u() : P && (u(), l());
        };
        document.addEventListener("pointermove", c), p(() => document.removeEventListener("pointermove", c));
      }
    }), (p, c) => (h(), b(wa, T({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: v(() => [
        y(p.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dp = /* @__PURE__ */ g({
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = zt(), l = pe(e, n);
    return (i, r) => a(s).open.value ? (h(), b(_e(a(s).disableHoverableContent.value ? wa : zr), R(T({ key: 0 }, a(l))), {
      default: v(() => [
        y(i.$slots, "default")
      ]),
      _: 3
    }, 16)) : G("", !0);
  }
}), cp = /* @__PURE__ */ g({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Xe), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pp = /* @__PURE__ */ g({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (h(), b(a(Te), R(K(t)), {
      default: v(() => [
        y(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
export {
  Qr as AccordionContent,
  eu as AccordionHeader,
  Zr as AccordionItem,
  Jr as AccordionRoot,
  tu as AccordionTrigger,
  cu as AlertDialogAction,
  ru as AlertDialogCancel,
  lu as AlertDialogContent,
  du as AlertDialogDescription,
  iu as AlertDialogOverlay,
  su as AlertDialogPortal,
  nu as AlertDialogRoot,
  uu as AlertDialogTitle,
  au as AlertDialogTrigger,
  pu as AspectRatio,
  mu as AvatarFallback,
  vu as AvatarImage,
  fu as AvatarRoot,
  yu as CheckboxIndicator,
  hu as CheckboxRoot,
  $s as CollapsibleContent,
  ws as CollapsibleRoot,
  Es as CollapsibleTrigger,
  Cu as ComboboxAnchor,
  Ou as ComboboxArrow,
  wu as ComboboxCancel,
  $u as ComboboxContent,
  Pu as ComboboxEmpty,
  Eu as ComboboxGroup,
  bu as ComboboxInput,
  Su as ComboboxItem,
  Tu as ComboboxItemIndicator,
  xu as ComboboxLabel,
  Iu as ComboboxPortal,
  gu as ComboboxRoot,
  Du as ComboboxSeparator,
  _u as ComboboxTrigger,
  Bu as ComboboxViewport,
  Yr as ConfigProvider,
  Vu as ContextMenuArrow,
  Nu as ContextMenuCheckboxItem,
  Ru as ContextMenuContent,
  Lu as ContextMenuGroup,
  Fu as ContextMenuItem,
  Hu as ContextMenuItemIndicator,
  Wu as ContextMenuLabel,
  ku as ContextMenuPortal,
  ju as ContextMenuRadioGroup,
  zu as ContextMenuRadioItem,
  Au as ContextMenuRoot,
  Ku as ContextMenuSeparator,
  Uu as ContextMenuSub,
  qu as ContextMenuSubContent,
  Gu as ContextMenuSubTrigger,
  Mu as ContextMenuTrigger,
  On as DialogClose,
  el as DialogContent,
  al as DialogDescription,
  ol as DialogOverlay,
  ou as DialogPortal,
  Os as DialogRoot,
  nl as DialogTitle,
  Is as DialogTrigger,
  Qu as DropdownMenuArrow,
  nd as DropdownMenuCheckboxItem,
  Zu as DropdownMenuContent,
  td as DropdownMenuGroup,
  ed as DropdownMenuItem,
  ad as DropdownMenuItemIndicator,
  sd as DropdownMenuLabel,
  Ju as DropdownMenuPortal,
  ld as DropdownMenuRadioGroup,
  id as DropdownMenuRadioItem,
  Yu as DropdownMenuRoot,
  od as DropdownMenuSeparator,
  rd as DropdownMenuSub,
  ud as DropdownMenuSubContent,
  dd as DropdownMenuSubTrigger,
  Xu as DropdownMenuTrigger,
  md as HoverCardArrow,
  vd as HoverCardContent,
  fd as HoverCardPortal,
  cd as HoverCardRoot,
  pd as HoverCardTrigger,
  hd as Label,
  wd as MenubarArrow,
  Pd as MenubarCheckboxItem,
  _d as MenubarContent,
  xd as MenubarGroup,
  Ed as MenubarItem,
  Bd as MenubarItemIndicator,
  Sd as MenubarLabel,
  gd as MenubarMenu,
  Cd as MenubarPortal,
  Td as MenubarRadioGroup,
  Dd as MenubarRadioItem,
  yd as MenubarRoot,
  $d as MenubarSeparator,
  Od as MenubarSub,
  Id as MenubarSubContent,
  Ad as MenubarSubTrigger,
  bd as MenubarTrigger,
  Rd as NavigationMenuContent,
  Vd as NavigationMenuIndicator,
  kd as NavigationMenuItem,
  Fd as NavigationMenuLink,
  Ld as NavigationMenuList,
  Md as NavigationMenuRoot,
  Kd as NavigationMenuSub,
  Nd as NavigationMenuTrigger,
  Hd as NavigationMenuViewport,
  jd as PaginationEllipsis,
  zd as PaginationFirst,
  Ud as PaginationLast,
  qd as PaginationList,
  Gd as PaginationListItem,
  Yd as PaginationNext,
  Xd as PaginationPrev,
  Wd as PaginationRoot,
  Zd as PinInputInput,
  Jd as PinInputRoot,
  sc as PopoverAnchor,
  nc as PopoverArrow,
  ac as PopoverClose,
  oc as PopoverContent,
  tc as PopoverPortal,
  Qd as PopoverRoot,
  ec as PopoverTrigger,
  D as Primitive,
  ic as ProgressIndicator,
  lc as ProgressRoot,
  dc as RadioGroupIndicator,
  uc as RadioGroupItem,
  rc as RadioGroupRoot,
  mc as ScrollAreaCorner,
  cc as ScrollAreaRoot,
  fc as ScrollAreaScrollbar,
  vc as ScrollAreaThumb,
  pc as ScrollAreaViewport,
  Cc as SelectArrow,
  bc as SelectContent,
  xc as SelectGroup,
  Oc as SelectIcon,
  wc as SelectItem,
  Ec as SelectItemIndicator,
  Pc as SelectItemText,
  $c as SelectLabel,
  gc as SelectPortal,
  hc as SelectRoot,
  Tc as SelectScrollDownButton,
  Sc as SelectScrollUpButton,
  _c as SelectSeparator,
  yc as SelectTrigger,
  Dc as SelectValue,
  Bc as SelectViewport,
  Ic as Separator,
  Rc as SliderRange,
  Ac as SliderRoot,
  Mc as SliderThumb,
  kc as SliderTrack,
  wo as Slot,
  Vc as SwitchRoot,
  Fc as SwitchThumb,
  Nc as TabsContent,
  Wc as TabsIndicator,
  Kc as TabsList,
  Lc as TabsRoot,
  Hc as TabsTrigger,
  Yc as TagsInputClear,
  zc as TagsInputInput,
  Uc as TagsInputItem,
  Gc as TagsInputItemDelete,
  qc as TagsInputItemText,
  jc as TagsInputRoot,
  Zc as ToastAction,
  Tr as ToastClose,
  tp as ToastDescription,
  Xc as ToastProvider,
  Jc as ToastRoot,
  ep as ToastTitle,
  Qc as ToastViewport,
  Dr as Toggle,
  Mr as ToggleGroupItem,
  Ar as ToggleGroupRoot,
  Rr as ToolbarButton,
  np as ToolbarLink,
  op as ToolbarRoot,
  lp as ToolbarSeparator,
  ap as ToolbarToggleGroup,
  sp as ToolbarToggleItem,
  cp as TooltipArrow,
  dp as TooltipContent,
  pp as TooltipPortal,
  ip as TooltipProvider,
  rp as TooltipRoot,
  up as TooltipTrigger,
  Je as VisuallyHidden,
  ce as useEmitAsProps,
  Ot as useForwardProps,
  pe as useForwardPropsEmits,
  te as useId,
  $n as useStateMachine,
  Xr as withDefault
};
